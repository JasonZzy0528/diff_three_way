{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///js/index.js","webpack:///webpack/bootstrap 43b23e97f1205b468482","webpack:///./node_modules/lodash/isArray.js","webpack:///./node_modules/lodash/isObject.js","webpack:///./node_modules/lodash/identity.js","webpack:///./node_modules/lodash/_baseGetTag.js","webpack:///./node_modules/lodash/isObjectLike.js","webpack:///./node_modules/lodash/isArrayLike.js","webpack:///./node_modules/lodash/_Symbol.js","webpack:///./node_modules/lodash/_root.js","webpack:///./node_modules/lodash/_arrayPush.js","webpack:///./node_modules/lodash/_freeGlobal.js","webpack:///./node_modules/lodash/isArguments.js","webpack:///./node_modules/lodash/_baseAssignValue.js","webpack:///./node_modules/lodash/_defineProperty.js","webpack:///./node_modules/lodash/isFunction.js","webpack:///./node_modules/lodash/eq.js","webpack:///./node_modules/lodash/isLength.js","webpack:///./node_modules/lodash/_isIndex.js","webpack:///./node_modules/lodash/_arrayLikeKeys.js","webpack:///(webpack)/buildin/module.js","webpack:///./node_modules/lodash/_isPrototype.js","webpack:///./node_modules/lodash/isSymbol.js","webpack:///./node_modules/lodash/_baseExtremum.js","webpack:///./src/index.js","webpack:///./node_modules/lodash/concat.js","webpack:///./node_modules/lodash/_baseFlatten.js","webpack:///./node_modules/lodash/_isFlattenable.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/lodash/_baseIsArguments.js","webpack:///./node_modules/lodash/_getRawTag.js","webpack:///./node_modules/lodash/_objectToString.js","webpack:///./node_modules/lodash/_copyArray.js","webpack:///./node_modules/lodash/extend.js","webpack:///./node_modules/lodash/assignIn.js","webpack:///./node_modules/lodash/_copyObject.js","webpack:///./node_modules/lodash/_assignValue.js","webpack:///./node_modules/lodash/_getNative.js","webpack:///./node_modules/lodash/_baseIsNative.js","webpack:///./node_modules/lodash/_isMasked.js","webpack:///./node_modules/lodash/_coreJsData.js","webpack:///./node_modules/lodash/_toSource.js","webpack:///./node_modules/lodash/_getValue.js","webpack:///./node_modules/lodash/_createAssigner.js","webpack:///./node_modules/lodash/_baseRest.js","webpack:///./node_modules/lodash/_overRest.js","webpack:///./node_modules/lodash/_apply.js","webpack:///./node_modules/lodash/_setToString.js","webpack:///./node_modules/lodash/_baseSetToString.js","webpack:///./node_modules/lodash/constant.js","webpack:///./node_modules/lodash/_shortOut.js","webpack:///./node_modules/lodash/_isIterateeCall.js","webpack:///./node_modules/lodash/keysIn.js","webpack:///./node_modules/lodash/_baseTimes.js","webpack:///./node_modules/lodash/isBuffer.js","webpack:///./node_modules/lodash/stubFalse.js","webpack:///./node_modules/lodash/isTypedArray.js","webpack:///./node_modules/lodash/_baseIsTypedArray.js","webpack:///./node_modules/lodash/_baseUnary.js","webpack:///./node_modules/lodash/_nodeUtil.js","webpack:///./node_modules/lodash/_baseKeysIn.js","webpack:///./node_modules/lodash/_nativeKeysIn.js","webpack:///./node_modules/lodash/forEach.js","webpack:///./node_modules/lodash/_arrayEach.js","webpack:///./node_modules/lodash/_baseEach.js","webpack:///./node_modules/lodash/_baseForOwn.js","webpack:///./node_modules/lodash/_baseFor.js","webpack:///./node_modules/lodash/_createBaseFor.js","webpack:///./node_modules/lodash/keys.js","webpack:///./node_modules/lodash/_baseKeys.js","webpack:///./node_modules/lodash/_nativeKeys.js","webpack:///./node_modules/lodash/_overArg.js","webpack:///./node_modules/lodash/_createBaseEach.js","webpack:///./node_modules/lodash/_castFunction.js","webpack:///./node_modules/lodash/indexOf.js","webpack:///./node_modules/lodash/_baseIndexOf.js","webpack:///./node_modules/lodash/_baseFindIndex.js","webpack:///./node_modules/lodash/_baseIsNaN.js","webpack:///./node_modules/lodash/_strictIndexOf.js","webpack:///./node_modules/lodash/toInteger.js","webpack:///./node_modules/lodash/toFinite.js","webpack:///./node_modules/lodash/toNumber.js","webpack:///./node_modules/lodash/max.js","webpack:///./node_modules/lodash/_baseGt.js","webpack:///./node_modules/lodash/min.js","webpack:///./node_modules/lodash/_baseLt.js","webpack:///./node_modules/diff-match-patch/index.js","webpack:///./src/util/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","isArray","Array","isObject","value","type","identity","baseGetTag","undefined","undefinedTag","nullTag","symToStringTag","getRawTag","objectToString","Symbol","toStringTag","isObjectLike","isArrayLike","isLength","length","isFunction","freeGlobal","freeSelf","self","Function","arrayPush","array","values","index","offset","global","baseIsArguments","objectProto","propertyIsEnumerable","isArguments","arguments","baseAssignValue","key","writable","getNative","func","e","tag","funcTag","genTag","asyncTag","proxyTag","eq","other","MAX_SAFE_INTEGER","isIndex","reIsUint","test","arrayLikeKeys","inherited","isArr","isArg","isBuff","isBuffer","isType","isTypedArray","skipIndexes","result","baseTimes","String","push","webpackPolyfill","deprecate","paths","children","isPrototype","Ctor","constructor","isSymbol","symbolTag","baseExtremum","iteratee","comparator","current","computed","_interopRequireDefault","obj","default","_classCallCheck","instance","Constructor","TypeError","_typeof","iterator","_createClass","defineProperties","target","props","descriptor","protoProps","staticProps","_concat","_concat2","_extend","_extend2","_forEach","_forEach2","_indexOf","_indexOf2","_isArray","_isArray2","_max","_max2","_min","_min2","_diffMatchPatch","_diffMatchPatch2","enableArrayEquals","Content","content","diffMatchPatch","newContent","patches","loadPatches","bind","applyPatch","setContent","getContent","threeWayMerge","updatePatches","patch","isReturnContent","patchObj","id","isApplied","isUpdated","Error","ptc","diffs","start1","length1","replacement","diff","substring","_this","updatedPatches","ptcId","ptcIsApplied","ptcIsUpdated","ptcObj","ptcOrgStart","ptcOrgEnd","patchOrgStart","patchOrgEnd","lengthChange","length2","start2","mergedResult","mergedContent","startChange","endChange","diffLength","opt","chars","newStart","newEnd","updatedPatchObj","patch_make","tmpDiffs","length2Change","tmp","tmpLength","tmpPatchObj","updatedPatch","err","console","log","optB","optC","contentLength","optBCharsRange","optCCharsRange","optBChanges","optCChanges","start","end","editingContent","contentDiff","genDiffLoop","optBDiff","genOptDiff","optCDiff","next","isPatchApplied","oneL","twoL","threeL","from","equals","op","splice","mergedPatch","mergedEditingContent","patch_apply","patchStatus","changes","_this2","text1","text2","change","orgChars","newChars","lengthUpdate","types","errorMessage","diff_main","range","me","optDiff","position","Math","floor","action","actionContent","begin","equalContent","equalDiff","char","patchText","patch_toText","newPatch","JSON","stringify","text","parse","patch_fromText","concat","args","copyArray","baseFlatten","depth","predicate","isStrict","isFlattenable","spreadableSymbol","isConcatSpreadable","g","eval","window","argsTag","isOwn","unmasked","nativeObjectToString","toString","source","copyObject","createAssigner","keysIn","assignIn","customizer","isNew","newValue","assignValue","objValue","getValue","baseIsNative","isMasked","reIsNative","reIsHostCtor","toSource","reRegExpChar","funcProto","funcToString","RegExp","replace","maskSrcKey","coreJsData","uid","exec","keys","IE_PROTO","assigner","baseRest","sources","guard","isIterateeCall","setToString","overRest","transform","nativeMax","otherArgs","apply","max","thisArg","baseSetToString","shortOut","constant","string","count","lastCalled","stamp","nativeNow","remaining","HOT_SPAN","HOT_COUNT","Date","now","baseKeysIn","stubFalse","freeExports","nodeType","freeModule","moduleExports","Buffer","nativeIsBuffer","baseIsTypedArray","baseUnary","nodeUtil","nodeIsTypedArray","typedArrayTags","freeProcess","process","binding","nativeKeysIn","isProto","forEach","collection","arrayEach","baseEach","castFunction","baseForOwn","createBaseEach","baseFor","createBaseFor","fromRight","keysFunc","iterable","baseKeys","nativeKeys","overArg","arg","eachFunc","indexOf","fromIndex","toInteger","baseIndexOf","strictIndexOf","baseFindIndex","baseIsNaN","toFinite","remainder","toNumber","INFINITY","MAX_INTEGER","NAN","valueOf","reTrim","isBinary","reIsBinary","reIsOctal","freeParseInt","slice","reIsBadHex","parseInt","baseGt","min","baseLt","diff_match_patch","Diff_Timeout","Diff_EditCost","Match_Threshold","Match_Distance","Patch_DeleteThreshold","Patch_Margin","Match_MaxBits","Diff","opt_checklines","opt_deadline","Number","MAX_VALUE","getTime","deadline","checklines","commonlength","diff_commonPrefix","commonprefix","diff_commonSuffix","commonsuffix","diff_compute_","unshift","diff_cleanupMerge","longtext","shorttext","hm","diff_halfMatch_","text1_a","text1_b","text2_a","text2_b","mid_common","diffs_a","diffs_b","diff_lineMode_","diff_bisect_","a","diff_linesToChars_","chars1","chars2","linearray","lineArray","diff_charsToLines_","diff_cleanupSemantic","pointer","count_delete","count_insert","text_delete","text_insert","j","pop","text1_length","text2_length","max_d","ceil","v_offset","v_length","v1","v2","x","delta","front","k1start","k1end","k2start","k2end","k1","x1","k1_offset","y1","charAt","k2_offset","x2","diff_bisectSplit_","k2","y2","y","text1a","text2a","text1b","text2b","diffsb","diff_linesToCharsMunge_","lineStart","lineEnd","lineArrayLength","line","lineHash","fromCharCode","charCodeAt","join","pointermin","pointermax","pointermid","pointerstart","pointerend","diff_commonOverlap_","text_length","best","pattern","found","diff_halfMatchI_","best_longtext_a","best_longtext_b","best_shorttext_a","best_shorttext_b","seed","best_common","prefixLength","dmp","suffixLength","hm1","hm2","equalities","equalitiesLength","lastequality","length_insertions1","length_deletions1","length_insertions2","length_deletions2","diff_cleanupSemanticLossless","deletion","insertion","overlap_length1","overlap_length2","diff_cleanupSemanticScore_","one","two","char1","char2","nonAlphaNumeric1","match","nonAlphaNumericRegex_","nonAlphaNumeric2","whitespace1","whitespaceRegex_","whitespace2","lineBreak1","linebreakRegex_","lineBreak2","blankLine1","blanklineEndRegex_","blankLine2","blanklineStartRegex_","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","score","diff_cleanupEfficiency","pre_ins","pre_del","post_ins","post_del","diff_xIndex","loc","last_chars1","last_chars2","diff_prettyHtml","html","pattern_amp","pattern_lt","pattern_gt","pattern_para","data","diff_text1","diff_text2","diff_levenshtein","levenshtein","insertions","deletions","diff_toDelta","encodeURI","diff_fromDelta","diffsLength","tokens","split","param","decodeURI","ex","isNaN","match_main","match_bitap_","match_bitapScore_","accuracy","proximity","abs","match_alphabet_","score_threshold","best_loc","lastIndexOf","matchmask","bin_min","bin_mid","last_rd","bin_max","finish","rd","charMatch","patch_addContext_","padding","prefix","suffix","opt_b","opt_c","patch_obj","patchDiffLength","char_count1","char_count2","prepatch_text","postpatch_text","diff_type","diff_text","patch_deepCopy","patchesCopy","patchCopy","nullPadding","patch_addPadding","patch_splitMax","results","start_loc","expected_loc","end_loc","index2","index1","mod","paddingLength","extraLength","patch_size","bigpatch","precontext","empty","shift","postcontext","textline","textPointer","patchHeader","sign","coords1","coords2","warn"],"mappings":"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","file":"js/index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"diff_three_way\"] = factory();\n\telse\n\t\troot[\"diff_three_way\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"diff_three_way\"] = factory();\n\telse\n\t\troot[\"diff_three_way\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 22);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(6),\n    getRawTag = __webpack_require__(28),\n    objectToString = __webpack_require__(29);\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isFunction = __webpack_require__(13),\n    isLength = __webpack_require__(15);\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar root = __webpack_require__(7);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar freeGlobal = __webpack_require__(9);\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsArguments = __webpack_require__(27),\n    isObjectLike = __webpack_require__(4);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar defineProperty = __webpack_require__(12);\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(35);\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(3),\n    isObject = __webpack_require__(1);\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseTimes = __webpack_require__(51),\n    isArguments = __webpack_require__(10),\n    isArray = __webpack_require__(0),\n    isBuffer = __webpack_require__(52),\n    isIndex = __webpack_require__(16),\n    isTypedArray = __webpack_require__(54);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(module) {\n\tif(!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif(!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(3),\n    isObjectLike = __webpack_require__(4);\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isSymbol = __webpack_require__(20);\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined\n          ? (current === current && !isSymbol(current))\n          : comparator(current, computed)\n        )) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseExtremum;\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* See LICENSE file for terms of use */\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _concat = __webpack_require__(23);\n\nvar _concat2 = _interopRequireDefault(_concat);\n\nvar _extend = __webpack_require__(31);\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _forEach = __webpack_require__(60);\n\nvar _forEach2 = _interopRequireDefault(_forEach);\n\nvar _indexOf = __webpack_require__(72);\n\nvar _indexOf2 = _interopRequireDefault(_indexOf);\n\nvar _isArray = __webpack_require__(0);\n\nvar _isArray2 = _interopRequireDefault(_isArray);\n\nvar _max = __webpack_require__(80);\n\nvar _max2 = _interopRequireDefault(_max);\n\nvar _min = __webpack_require__(82);\n\nvar _min2 = _interopRequireDefault(_min);\n\nvar _diffMatchPatch = __webpack_require__(84);\n\nvar _diffMatchPatch2 = _interopRequireDefault(_diffMatchPatch);\n\nvar _util = __webpack_require__(85);\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n_util2.default.enableArrayEquals();\n\nvar Content = function () {\n  function Content(content) {\n    _classCallCheck(this, Content);\n\n    this.diffMatchPatch = new _diffMatchPatch2.default();\n    this.content = content;\n    this.newContent = undefined;\n    this.patches = [];\n    this.loadPatches = this.loadPatches.bind(this);\n    this.applyPatch = this.applyPatch.bind(this);\n    this.setContent = this.setContent.bind(this);\n    this.getContent = this.getContent.bind(this);\n    this.threeWayMerge = this.threeWayMerge.bind(this);\n    this.updatePatches = this.updatePatches.bind(this);\n  }\n\n  _createClass(Content, [{\n    key: 'loadPatches',\n    value: function loadPatches(patches) {\n      this.patches = (0, _concat2.default)([], patches);\n    }\n  }, {\n    key: 'addPatch',\n    value: function addPatch(patch) {\n      this.patches.push([patch, true]);\n    }\n  }, {\n    key: 'applyPatch',\n    value: function applyPatch(patch, isReturnContent) {\n      var content = this.content;\n      var patchObj = patch.patchObj,\n          id = patch.id,\n          isApplied = patch.isApplied,\n          isUpdated = patch.isUpdated;\n\n      if (isApplied) {\n        throw new Error('The patch cannot be applied, because it was applied before');\n      }\n      if (!isUpdated) {\n        throw new Error('The patch cannot be applied, because it has conflict');\n      }\n      if (id === undefined || id === null) {\n        throw new Error('id cannot be undefined or null');\n      }\n      (0, _forEach2.default)(patchObj, function (ptc) {\n        var diffs = ptc.diffs,\n            start1 = ptc.start1,\n            length1 = ptc.length1;\n\n        var replacement = '';\n        (0, _forEach2.default)(diffs, function (diff) {\n          if (diff[0] !== -1) {\n            replacement += diff[1];\n          }\n        });\n        content = content.substring(0, start1) + replacement + content.substring(start1 + length1, content.length);\n      });\n      if (isReturnContent) {\n        return content;\n      } else {\n        this.newContent = content;\n        this.updatePatches(patch);\n      }\n    }\n  }, {\n    key: 'updatePatches',\n    value: function updatePatches(patch) {\n      var _this = this;\n\n      var patches = (0, _concat2.default)([], this.patches);\n      var patchObj = patch.patchObj,\n          id = patch.id;\n\n      if (patchObj.length === 0) {\n        throw new Error('patchObj cannot be empty');\n      }\n      var content = this.content,\n          newContent = this.newContent;\n\n      var updatedPatches = [];\n      (0, _forEach2.default)(patches, function (ptc) {\n        var ptcId = ptc.id;\n        if (ptcId === id) {\n          ptc.isApplied = true;\n          ptc.isUpdated = true;\n          updatedPatches.push(ptc);\n        } else {\n          var ptcIsApplied = ptc.isApplied;\n          var ptcIsUpdated = ptc.isUpdated;\n          if (ptcIsApplied || !ptcIsUpdated) {\n            updatedPatches.push(ptc);\n          } else {\n            var ptcObj = ptc.patchObj;\n            var ptcOrgStart = ptcObj[0].start1;\n            var ptcOrgEnd = ptcObj[ptcObj.length - 1].start1 + ptcObj[ptcObj.length - 1].length1;\n            var patchOrgStart = patchObj[0].start1;\n            var patchOrgEnd = patchObj[patchObj.length - 1].start1 + patchObj[patchObj.length - 1].length1;\n            if (ptcOrgStart > patchOrgEnd) {\n              var lengthChange = 0;\n              (0, _forEach2.default)(patchObj, function (obj) {\n                lengthChange += obj.length2 - obj.length1;\n              });\n              (0, _forEach2.default)(ptcObj, function (obj, index) {\n                ptc.patchObj[index].start1 += lengthChange;\n                ptc.patchObj[index].start2 += lengthChange;\n              });\n              updatedPatches.push(ptc);\n            } else if (ptcOrgEnd < patchOrgStart) {\n              updatedPatches.push(ptc);\n            } else {\n              try {\n                var mergedResult = _this.threeWayMerge(content, patchObj, ptcObj);\n                var mergedContent = mergedResult[0];\n                var startChange = 0;\n                var endChange = 0;\n                (0, _forEach2.default)(patchObj, function (obj) {\n                  if (obj.start1 + obj.length1 <= ptcOrgStart + startChange) {\n                    startChange += obj.length2 - obj.length1;\n                    endChange += obj.length2 - obj.length1;\n                  } else if (obj.start1 <= ptcOrgStart + startChange) {\n                    var diffLength = 0;\n                    (0, _forEach2.default)(obj.diffs, function (diff) {\n                      var opt = diff[0];\n                      var chars = diff[1];\n                      if (obj.start1 + diffLength <= ptcOrgStart + startChange) {\n                        startChange += opt * chars.length;\n                        endChange += opt * chars.length;\n                      } else {\n                        if (ptcOrgStart + startChange - obj.start1 - diffLength + chars.length >= 0) {\n                          startChange += opt * (ptcOrgStart + startChange - obj.start1 - diffLength + chars.length);\n                        }\n                        if (obj.start1 + diffLength <= ptcOrgEnd + endChange) {\n                          endChange += opt * chars.length;\n                        } else if (obj.start1 + diffLength - chars.length <= ptcOrgEnd + endChange) {\n                          endChange += opt * (ptcOrgEnd + endChange - obj.start1 - diffLength + chars.length);\n                        }\n                      }\n                      diffLength += chars.length;\n                    });\n                  } else if (obj.start1 > ptcOrgStart && obj.start1 + obj.length1 <= ptcOrgEnd) {\n                    var _diffLength = void 0;\n                    (0, _forEach2.default)(obj.diffs, function (diff) {\n                      var opt = diff[0];\n                      var chars = diff[1];\n                      if (obj.start1 + _diffLength <= ptcOrgEnd + endChange) {\n                        endChange += opt * chars.length;\n                      } else if (obj.start1 + _diffLength - chars.length <= ptcOrgEnd + endChange) {\n                        endChange += opt * (ptcOrgEnd + endChange - obj.start1 - _diffLength + chars.length);\n                      }\n                      _diffLength += chars.length;\n                    });\n                  }\n                });\n                var newStart = ptc.patchObj[0].start1 + startChange;\n                var newEnd = ptc.patchObj[ptc.patchObj.length - 1].start1 + ptc.patchObj[ptc.patchObj.length - 1].length1 + endChange;\n                var updatedPatchObj = _this.diffMatchPatch.patch_make(newContent, mergedContent);\n                var tmpDiffs = [];\n                var length2Change = 0;\n                (0, _forEach2.default)(updatedPatchObj, function (tmp, index) {\n                  if (tmp.start1 > newEnd || tmp.start1 + tmp.length1 < newStart) {\n                    return;\n                  }\n                  if (tmp.start1 <= newStart) {\n                    if (tmp.start1 + tmp.length1 < newStart) {\n                      return;\n                    } else {\n                      var tmpLength = 0;\n                      (0, _forEach2.default)(tmp.diffs, function (diff) {\n                        var opt = diff[0];\n                        var chars = diff[1];\n                        if (opt === 0) {\n                          if (chars.length + tmp.start1 + tmpLength > newStart && chars.length + tmp.start1 + tmpLength <= newEnd) {\n                            tmpDiffs.push([opt, chars.substring(newStart - tmp.start1 - tmpLength, chars.length)]);\n                          } else if (chars.length + tmp.start1 + tmpLength >= newStart && chars.length + tmp.start1 + tmpLength >= newEnd && tmp.start1 + tmpLength < newEnd) {\n                            tmpDiffs.push([opt, chars.substring(chars.length + tmp.start1 + tmpLength - newStart, newEnd - tmp.start1 - tmpLength)]);\n                          }\n                          tmpLength += chars.length;\n                        } else {\n                          if (tmp.start1 + tmpLength <= newEnd) {\n                            tmpDiffs.push(diff);\n                            length2Change += opt * chars.length;\n                          }\n                        }\n                      });\n                    }\n                  } else if (tmp.start1 >= newStart) {\n                    if (tmp.start1 > newEnd) {\n                      return;\n                    }\n                    if (tmp.start1 + tmp.length1 >= newEnd) {\n                      if (index === 0) {\n                        tmpDiffs.push([0, newContent.substring(newStart, tmp.start1)]);\n                        var _tmpLength = 0;\n                        (0, _forEach2.default)(tmp.diffs, function (diff) {\n                          var opt = diff[0];\n                          var chars = diff[1];\n                          if (opt === 0) {\n                            if (chars.length + tmp.start1 + _tmpLength > newEnd) {\n                              tmpDiffs.push([opt, chars.substring(0, newEnd - tmp.start1 - _tmpLength)]);\n                            }\n                            _tmpLength += chars.length;\n                          } else {\n                            if (tmp.start1 + _tmpLength < newEnd) {\n                              tmpDiffs.push(diff);\n                              length2Change += opt * chars.length;\n                            }\n                          }\n                        });\n                      } else {\n                        var _tmpLength2 = 0;\n                        (0, _forEach2.default)(tmp.diffs, function (diff) {\n                          var opt = diff[0];\n                          var chars = diff[1];\n                          if (opt === 0) {\n                            if (chars.length + tmp.start1 + _tmpLength2 > newEnd) {\n                              tmpDiffs.push([opt, chars.substring(0, newEnd - tmp.start1 - _tmpLength2)]);\n                            } else {\n                              tmpDiffs.push(diff);\n                            }\n                            _tmpLength2 += chars.length;\n                          } else {\n                            if (tmp.start1 + _tmpLength2 < newEnd) {\n                              tmpDiffs.push(diff);\n                              length2Change += opt * chars.length;\n                            }\n                          }\n                        });\n                      }\n                    } else {\n                      if (index === 0) {\n                        tmpDiffs.push([0, newContent.substring(newStart, tmp.start1)]);\n                      }\n                      tmpDiffs = (0, _concat2.default)(tmpDiffs, tmp.diffs);\n                    }\n                  }\n                  if (index === updatedPatchObj.length - 1) {\n                    if (tmp.start1 + tmp.length1 <= newEnd) {\n                      tmpDiffs.push([0, newContent.substring(tmp.start1 + tmp.length1, newEnd)]);\n                    }\n                  }\n                });\n                var tmpPatchObj = [{\n                  diffs: tmpDiffs,\n                  start1: newStart,\n                  start2: newStart,\n                  length1: newEnd - newStart,\n                  length2: newEnd - newStart + length2Change\n                }];\n                var updatedPatch = {\n                  patchObj: tmpPatchObj,\n                  id: ptcId,\n                  isApplied: false,\n                  isUpdated: true\n                };\n                updatedPatches.push(updatedPatch);\n              } catch (err) {\n                console.log(err);\n                ptc.isUpdated = false;\n                updatedPatches.push(ptc);\n              }\n            }\n          }\n        }\n      });\n      this.patches = updatedPatches;\n      this.setContent(newContent);\n      this.newContent = undefined;\n    }\n  }, {\n    key: 'threeWayMerge',\n    value: function threeWayMerge(content, optB, optC) {\n      var contentLength = content.length;\n      var optBCharsRange = [];\n      var optCCharsRange = [];\n      var optBChanges = 0;\n      var optCChanges = 0;\n      (0, _forEach2.default)(optB, function (patch) {\n        var start1 = patch.start1,\n            length1 = patch.length1,\n            length2 = patch.length2;\n\n        optBCharsRange.push(start1 - optBChanges);\n        if (start1 === 0) {\n          optBCharsRange.push(start1 - optBChanges + length1 - 1);\n        } else {\n          optBCharsRange.push(start1 - optBChanges + length1);\n        }\n        optBChanges += length2 - length1;\n      });\n      (0, _forEach2.default)(optC, function (patch) {\n        var start1 = patch.start1,\n            length1 = patch.length1,\n            length2 = patch.length2;\n\n        optCCharsRange.push(start1 - optCChanges);\n        if (start1 === 0) {\n          optCCharsRange.push(start1 - optCChanges + length1 - 1);\n        } else {\n          optCCharsRange.push(start1 - optCChanges + length1);\n        }\n        optCChanges += length2 - length1;\n      });\n\n      var start = (0, _min2.default)([(0, _min2.default)(optBCharsRange), (0, _min2.default)(optCCharsRange)]);\n      var end = (0, _max2.default)([(0, _max2.default)(optBCharsRange), (0, _max2.default)(optCCharsRange)]);\n      if (end >= contentLength) throw new Error('incorrect patch');\n      var editingContent = content.substring(start, end);\n      var contentDiff = this.genDiffLoop(0, editingContent);\n      var optBDiff = this.genOptDiff(optBCharsRange, optB, content, start, end);\n      var optCDiff = this.genOptDiff(optCCharsRange, optC, content, start, end);\n      var next = true;\n      var i = 0;\n      var newContent = [];\n      var isPatchApplied = true;\n      while (next) {\n        var oneL = contentDiff[i];\n        var twoL = optBDiff[i];\n        var threeL = optCDiff[i];\n        var from = void 0;\n        if (oneL || twoL || threeL) {\n          var l = void 0;\n          if (oneL && twoL && threeL) {\n            if (oneL.equals(twoL)) {\n              l = threeL;\n              from = 'three';\n            } else if (oneL.equals(threeL)) {\n              l = twoL;\n              from = 'two';\n            } else if (twoL.equals(threeL)) {\n              l = twoL;\n              from = 'both';\n            }\n          } else if (twoL && !threeL) {\n            l = twoL;\n            from = 'two';\n          } else if (!twoL && threeL) {\n            l = threeL;\n            from = 'three';\n          }\n\n          if (l === undefined) {\n            throw new Error('Conflict at position ', i);\n          } else {\n            var op = l[0];\n            if (op == 1) {\n              var index = i == 0 ? 0 : i - 1;\n              if (from == 'two') {\n                contentDiff.splice(index, 0, l);\n                optCDiff.splice(index, 0, l);\n              } else if (from == 'three') {\n                contentDiff.splice(index, 0, l);\n                optBDiff.splice(index, 0, l);\n              } else {\n                contentDiff.splice(index, 0, l);\n              }\n            } else if (op == -1) {\n              if (from == 'two') {\n                contentDiff.splice(i, 1, l);\n                optCDiff.splice(i, 1, l);\n              } else if (from == 'three') {\n                contentDiff.splice(i, 1, l);\n                optBDiff.splice(i, 1, l);\n              } else {\n                //  from == 'both'\n                contentDiff.splice(i, 1, l);\n              }\n            }\n            newContent.push(l);\n          }\n        }\n        next = next != false && (contentDiff[i + 1] || optBDiff[i + 1] || optCDiff[i + 1]);\n        i++;\n      }\n\n      var mergedPatch = this.diffMatchPatch.patch_make(newContent);\n      var mergedEditingContent = this.diffMatchPatch.patch_apply(mergedPatch, editingContent);\n      isPatchApplied = this.isPatchApplied(mergedEditingContent[1]);\n      if (!isPatchApplied) throw new Error('Conflict happened');\n      var mergedContent = content.substring(0, start) + mergedEditingContent[0] + content.substring(end, contentLength);\n      return [mergedContent, isPatchApplied];\n    }\n  }, {\n    key: 'isPatchApplied',\n    value: function isPatchApplied(patchStatus) {\n      return (0, _indexOf2.default)(patchStatus, false) === -1;\n    }\n  }, {\n    key: 'updateContent',\n    value: function updateContent(content) {\n      this.content = content;\n    }\n  }, {\n    key: 'getPatches',\n    value: function getPatches() {\n      return (0, _concat2.default)([], this.patches);\n    }\n  }, {\n    key: 'getContent',\n    value: function getContent() {\n      return this.content;\n    }\n  }, {\n    key: 'setContent',\n    value: function setContent(content) {\n      var type = typeof content === 'undefined' ? 'undefined' : _typeof(content);\n      if (type === 'string') {\n        this.content = content;\n        return;\n      }\n      throw new TypeError('String expected, but got ' + type);\n    }\n  }, {\n    key: 'createPatch',\n    value: function createPatch(changes) {\n      var _this2 = this;\n\n      var type = typeof changes === 'undefined' ? 'undefined' : _typeof(changes);\n      if (type === 'object' && !(0, _isArray2.default)(changes)) {\n        var id = changes.id,\n            text1 = changes.text1,\n            text2 = changes.text2;\n\n        var patchObj = this.diffMatchPatch.patch_make(text1, text2);\n        var patches = {\n          patchObj: patchObj,\n          id: id,\n          isUpdated: true,\n          isApplied: false\n        };\n        return patches;\n      } else if (type === 'object') {\n        var _patches = {\n          patchObj: [],\n          id: changes[0].id,\n          isUpdated: true,\n          isApplied: false\n        };\n        var lengthChange = 0;\n        (0, _forEach2.default)(changes, function (change, index) {\n          var start = change.start,\n              orgChars = change.orgChars,\n              newChars = change.newChars;\n\n          var lengthUpdate = 0;\n          var types = [typeof start === 'undefined' ? 'undefined' : _typeof(start), typeof orgChars === 'undefined' ? 'undefined' : _typeof(orgChars), typeof newChars === 'undefined' ? 'undefined' : _typeof(newChars)];\n          var errorMessage = void 0;\n          if (types[0] !== 'number') {\n            errorMessage = 'Number expected, but got ' + types[0];\n          }\n          if (types[1] !== 'string') {\n            errorMessage = 'String expected, but got ' + types[1];\n          }\n          if (types[2] !== 'string') {\n            errorMessage = 'String expected, but got ' + types[2];\n          }\n          if (errorMessage) {\n            throw new TypeError(errorMessage);\n          }\n          var diffs = _this2.diffMatchPatch.diff_main(orgChars, newChars);\n          (0, _forEach2.default)(diffs, function (diff) {\n            var opt = diff[0];\n            var length = diff[1].length;\n            lengthUpdate += opt * length;\n          });\n          var length1 = orgChars.length;\n          var length2 = newChars.length;\n          var patch = {};\n          if (index === 0) {\n            patch = {\n              diffs: diffs,\n              start1: start,\n              start2: start,\n              length1: length1,\n              length2: length2\n            };\n          } else {\n            patch = {\n              diffs: diffs,\n              start1: start + lengthChange,\n              start2: start + lengthChange,\n              length1: length1,\n              length2: length2\n            };\n          }\n          _patches.patchObj.push(patch);\n          lengthChange += lengthUpdate;\n        });\n        return _patches;\n      }\n      throw new TypeError('String expected, but got ' + type);\n    }\n  }, {\n    key: 'genOptDiff',\n    value: function genOptDiff(range, patches, content, start, end) {\n      var me = this;\n      var optDiff = [];\n      (0, _forEach2.default)(range, function (position, index) {\n        if (index % 2 !== 0) {\n          var patch = patches[Math.floor(index / 2)];\n          (0, _forEach2.default)(patch.diffs, function (diff) {\n            var action = diff[0];\n            var actionContent = diff[1];\n            var diffs = [];\n            if (actionContent.length > 1) {\n              diffs = me.genDiffLoop(action, actionContent);\n            } else {\n              diffs.push(diff);\n            }\n            optDiff = (0, _concat2.default)(optDiff, diffs);\n          });\n        } else {\n          var begin = index === 0 ? start : range[index - 1];\n          if (position > begin) {\n            var equalContent = content.substring(begin, position);\n            var equalDiff = me.genDiffLoop(0, equalContent);\n            optDiff = (0, _concat2.default)(optDiff, equalDiff);\n          }\n        }\n        if (index === range.length - 1 && position !== end) {\n          var _equalContent = content.substring(position, end);\n          var _equalDiff = me.genDiffLoop(0, _equalContent);\n          optDiff = (0, _concat2.default)(optDiff, _equalDiff);\n        }\n      });\n      return optDiff;\n    }\n  }, {\n    key: 'genDiffLoop',\n    value: function genDiffLoop(action, content) {\n      var diffs = [];\n      (0, _forEach2.default)(content, function (char) {\n        diffs.push([action, char]);\n      });\n      return diffs;\n    }\n  }, {\n    key: 'patchToText',\n    value: function patchToText(patches) {\n      var patchObj = patches.patchObj;\n\n      var patchText = this.diffMatchPatch.patch_toText(patchObj);\n      var newPatch = (0, _extend2.default)({}, patches, { patchObj: patchText });\n      return JSON.stringify(newPatch);\n    }\n  }, {\n    key: 'patchFromText',\n    value: function patchFromText(text) {\n      var patch = JSON.parse(text);\n      var patchObj = this.diffMatchPatch.patch_fromText(patch.patchObj);\n      var newPatch = (0, _extend2.default)({}, patch, { patchObj: patchObj });\n      return newPatch;\n    }\n  }]);\n\n  return Content;\n}();\n\nexports.default = Content;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayPush = __webpack_require__(8),\n    baseFlatten = __webpack_require__(24),\n    copyArray = __webpack_require__(30),\n    isArray = __webpack_require__(0);\n\n/**\n * Creates a new array concatenating `array` with any additional arrays\n * and/or values.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to concatenate.\n * @param {...*} [values] The values to concatenate.\n * @returns {Array} Returns the new concatenated array.\n * @example\n *\n * var array = [1];\n * var other = _.concat(array, 2, [3], [[4]]);\n *\n * console.log(other);\n * // => [1, 2, 3, [4]]\n *\n * console.log(array);\n * // => [1]\n */\nfunction concat() {\n  var length = arguments.length;\n  if (!length) {\n    return [];\n  }\n  var args = Array(length - 1),\n      array = arguments[0],\n      index = length;\n\n  while (index--) {\n    args[index - 1] = arguments[index];\n  }\n  return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n}\n\nmodule.exports = concat;\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayPush = __webpack_require__(8),\n    isFlattenable = __webpack_require__(25);\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(6),\n    isArguments = __webpack_require__(10),\n    isArray = __webpack_require__(0);\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\n} catch(e) {\n\t// This works if the window reference is available\n\tif(typeof window === \"object\")\n\t\tg = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(3),\n    isObjectLike = __webpack_require__(4);\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(6);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports) {\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(32);\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar copyObject = __webpack_require__(33),\n    createAssigner = __webpack_require__(41),\n    keysIn = __webpack_require__(50);\n\n/**\n * This method is like `_.assign` except that it iterates over own and\n * inherited source properties.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @alias extend\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.assign\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * function Bar() {\n *   this.c = 3;\n * }\n *\n * Foo.prototype.b = 2;\n * Bar.prototype.d = 4;\n *\n * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n */\nvar assignIn = createAssigner(function(object, source) {\n  copyObject(source, keysIn(source), object);\n});\n\nmodule.exports = assignIn;\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assignValue = __webpack_require__(34),\n    baseAssignValue = __webpack_require__(11);\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseAssignValue = __webpack_require__(11),\n    eq = __webpack_require__(14);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsNative = __webpack_require__(36),\n    getValue = __webpack_require__(40);\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isFunction = __webpack_require__(13),\n    isMasked = __webpack_require__(37),\n    isObject = __webpack_require__(1),\n    toSource = __webpack_require__(39);\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar coreJsData = __webpack_require__(38);\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar root = __webpack_require__(7);\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports) {\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseRest = __webpack_require__(42),\n    isIterateeCall = __webpack_require__(49);\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar identity = __webpack_require__(2),\n    overRest = __webpack_require__(43),\n    setToString = __webpack_require__(45);\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar apply = __webpack_require__(44);\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports) {\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseSetToString = __webpack_require__(46),\n    shortOut = __webpack_require__(48);\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar constant = __webpack_require__(47),\n    defineProperty = __webpack_require__(12),\n    identity = __webpack_require__(2);\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports) {\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports) {\n\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar eq = __webpack_require__(14),\n    isArrayLike = __webpack_require__(5),\n    isIndex = __webpack_require__(16),\n    isObject = __webpack_require__(1);\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayLikeKeys = __webpack_require__(17),\n    baseKeysIn = __webpack_require__(58),\n    isArrayLike = __webpack_require__(5);\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(7),\n    stubFalse = __webpack_require__(53);\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(18)(module)))\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports) {\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsTypedArray = __webpack_require__(55),\n    baseUnary = __webpack_require__(56),\n    nodeUtil = __webpack_require__(57);\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(3),\n    isLength = __webpack_require__(15),\n    isObjectLike = __webpack_require__(4);\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(9);\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(18)(module)))\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(1),\n    isPrototype = __webpack_require__(19),\n    nativeKeysIn = __webpack_require__(59);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports) {\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayEach = __webpack_require__(61),\n    baseEach = __webpack_require__(62),\n    castFunction = __webpack_require__(71),\n    isArray = __webpack_require__(0);\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\nmodule.exports = forEach;\n\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseForOwn = __webpack_require__(63),\n    createBaseEach = __webpack_require__(70);\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFor = __webpack_require__(64),\n    keys = __webpack_require__(66);\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createBaseFor = __webpack_require__(65);\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports) {\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayLikeKeys = __webpack_require__(17),\n    baseKeys = __webpack_require__(67),\n    isArrayLike = __webpack_require__(5);\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isPrototype = __webpack_require__(19),\n    nativeKeys = __webpack_require__(68);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar overArg = __webpack_require__(69);\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports) {\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArrayLike = __webpack_require__(5);\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar identity = __webpack_require__(2);\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\nmodule.exports = castFunction;\n\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIndexOf = __webpack_require__(73),\n    toInteger = __webpack_require__(77);\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Gets the index at which the first occurrence of `value` is found in `array`\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. If `fromIndex` is negative, it's used as the\n * offset from the end of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n * @example\n *\n * _.indexOf([1, 2, 1, 2], 2);\n * // => 1\n *\n * // Search from the `fromIndex`.\n * _.indexOf([1, 2, 1, 2], 2, 2);\n * // => 3\n */\nfunction indexOf(array, value, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseIndexOf(array, value, index);\n}\n\nmodule.exports = indexOf;\n\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFindIndex = __webpack_require__(74),\n    baseIsNaN = __webpack_require__(75),\n    strictIndexOf = __webpack_require__(76);\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\nmodule.exports = baseIndexOf;\n\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\nmodule.exports = baseIsNaN;\n\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = strictIndexOf;\n\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toFinite = __webpack_require__(78);\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toNumber = __webpack_require__(79);\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(1),\n    isSymbol = __webpack_require__(20);\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseExtremum = __webpack_require__(21),\n    baseGt = __webpack_require__(81),\n    identity = __webpack_require__(2);\n\n/**\n * Computes the maximum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the maximum value.\n * @example\n *\n * _.max([4, 2, 8, 6]);\n * // => 8\n *\n * _.max([]);\n * // => undefined\n */\nfunction max(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseGt)\n    : undefined;\n}\n\nmodule.exports = max;\n\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.gt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is greater than `other`,\n *  else `false`.\n */\nfunction baseGt(value, other) {\n  return value > other;\n}\n\nmodule.exports = baseGt;\n\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseExtremum = __webpack_require__(21),\n    baseLt = __webpack_require__(83),\n    identity = __webpack_require__(2);\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseLt)\n    : undefined;\n}\n\nmodule.exports = min;\n\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt(value, other) {\n  return value < other;\n}\n\nmodule.exports = baseLt;\n\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\n/**\r\n * Diff Match and Patch\r\n *\r\n * Copyright 2006 Google Inc.\r\n * http://code.google.com/p/google-diff-match-patch/\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @fileoverview Computes the difference between two texts to create a patch.\r\n * Applies the patch onto another text, allowing for errors.\r\n * @author fraser@google.com (Neil Fraser)\r\n */\r\n\r\n/**\r\n * Class containing the diff, match and patch methods.\r\n * @constructor\r\n */\r\nfunction diff_match_patch() {\r\n\r\n  // Defaults.\r\n  // Redefine these in your program to override the defaults.\r\n\r\n  // Number of seconds to map a diff before giving up (0 for infinity).\r\n  this.Diff_Timeout = 1.0;\r\n  // Cost of an empty edit operation in terms of edit characters.\r\n  this.Diff_EditCost = 4;\r\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\r\n  this.Match_Threshold = 0.5;\r\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\r\n  // A match this many characters away from the expected location will add\r\n  // 1.0 to the score (0.0 is a perfect match).\r\n  this.Match_Distance = 1000;\r\n  // When deleting a large block of text (over ~64 characters), how close do\r\n  // the contents have to be to match the expected contents. (0.0 = perfection,\r\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\r\n  // end points of a delete need to match.\r\n  this.Patch_DeleteThreshold = 0.5;\r\n  // Chunk size for context length.\r\n  this.Patch_Margin = 4;\r\n\r\n  // The number of bits in an int.\r\n  this.Match_MaxBits = 32;\r\n}\r\n\r\n\r\n//  DIFF FUNCTIONS\r\n\r\n\r\n/**\r\n * The data structure representing a diff is an array of tuples:\r\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\r\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\r\n */\r\nvar DIFF_DELETE = -1;\r\nvar DIFF_INSERT = 1;\r\nvar DIFF_EQUAL = 0;\r\n\r\n/** @typedef {{0: number, 1: string}} */\r\ndiff_match_patch.Diff;\r\n\r\n\r\n/**\r\n * Find the differences between two texts.  Simplifies the problem by stripping\r\n * any common prefix or suffix off the texts before diffing.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\r\n *     then don't run a line-level diff first to identify the changed areas.\r\n *     Defaults to true, which does a faster, slightly less optimal diff.\r\n * @param {number} opt_deadline Optional time when the diff should be complete\r\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\r\n *     instead.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\r\n    opt_deadline) {\r\n  // Set a deadline by which time the diff must be complete.\r\n  if (typeof opt_deadline == 'undefined') {\r\n    if (this.Diff_Timeout <= 0) {\r\n      opt_deadline = Number.MAX_VALUE;\r\n    } else {\r\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\r\n    }\r\n  }\r\n  var deadline = opt_deadline;\r\n\r\n  // Check for null inputs.\r\n  if (text1 == null || text2 == null) {\r\n    throw new Error('Null input. (diff_main)');\r\n  }\r\n\r\n  // Check for equality (speedup).\r\n  if (text1 == text2) {\r\n    if (text1) {\r\n      return [[DIFF_EQUAL, text1]];\r\n    }\r\n    return [];\r\n  }\r\n\r\n  if (typeof opt_checklines == 'undefined') {\r\n    opt_checklines = true;\r\n  }\r\n  var checklines = opt_checklines;\r\n\r\n  // Trim off common prefix (speedup).\r\n  var commonlength = this.diff_commonPrefix(text1, text2);\r\n  var commonprefix = text1.substring(0, commonlength);\r\n  text1 = text1.substring(commonlength);\r\n  text2 = text2.substring(commonlength);\r\n\r\n  // Trim off common suffix (speedup).\r\n  commonlength = this.diff_commonSuffix(text1, text2);\r\n  var commonsuffix = text1.substring(text1.length - commonlength);\r\n  text1 = text1.substring(0, text1.length - commonlength);\r\n  text2 = text2.substring(0, text2.length - commonlength);\r\n\r\n  // Compute the diff on the middle block.\r\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\r\n\r\n  // Restore the prefix and suffix.\r\n  if (commonprefix) {\r\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\r\n  }\r\n  if (commonsuffix) {\r\n    diffs.push([DIFF_EQUAL, commonsuffix]);\r\n  }\r\n  this.diff_cleanupMerge(diffs);\r\n  return diffs;\r\n};\r\n\r\n\r\n/**\r\n * Find the differences between two texts.  Assumes that the texts do not\r\n * have any common prefix or suffix.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\r\n *     line-level diff first to identify the changed areas.\r\n *     If true, then run a faster, slightly less optimal diff.\r\n * @param {number} deadline Time when the diff should be complete by.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\r\n    deadline) {\r\n  var diffs;\r\n\r\n  if (!text1) {\r\n    // Just add some text (speedup).\r\n    return [[DIFF_INSERT, text2]];\r\n  }\r\n\r\n  if (!text2) {\r\n    // Just delete some text (speedup).\r\n    return [[DIFF_DELETE, text1]];\r\n  }\r\n\r\n  var longtext = text1.length > text2.length ? text1 : text2;\r\n  var shorttext = text1.length > text2.length ? text2 : text1;\r\n  var i = longtext.indexOf(shorttext);\r\n  if (i != -1) {\r\n    // Shorter text is inside the longer text (speedup).\r\n    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\r\n             [DIFF_EQUAL, shorttext],\r\n             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\r\n    // Swap insertions for deletions if diff is reversed.\r\n    if (text1.length > text2.length) {\r\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\r\n    }\r\n    return diffs;\r\n  }\r\n\r\n  if (shorttext.length == 1) {\r\n    // Single character string.\r\n    // After the previous speedup, the character can't be an equality.\r\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\r\n  }\r\n\r\n  // Check to see if the problem can be split in two.\r\n  var hm = this.diff_halfMatch_(text1, text2);\r\n  if (hm) {\r\n    // A half-match was found, sort out the return data.\r\n    var text1_a = hm[0];\r\n    var text1_b = hm[1];\r\n    var text2_a = hm[2];\r\n    var text2_b = hm[3];\r\n    var mid_common = hm[4];\r\n    // Send both pairs off for separate processing.\r\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\r\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\r\n    // Merge the results.\r\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\r\n  }\r\n\r\n  if (checklines && text1.length > 100 && text2.length > 100) {\r\n    return this.diff_lineMode_(text1, text2, deadline);\r\n  }\r\n\r\n  return this.diff_bisect_(text1, text2, deadline);\r\n};\r\n\r\n\r\n/**\r\n * Do a quick line-level diff on both strings, then rediff the parts for\r\n * greater accuracy.\r\n * This speedup can produce non-minimal diffs.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {number} deadline Time when the diff should be complete by.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\r\n  // Scan the text on a line-by-line basis first.\r\n  var a = this.diff_linesToChars_(text1, text2);\r\n  text1 = a.chars1;\r\n  text2 = a.chars2;\r\n  var linearray = a.lineArray;\r\n\r\n  var diffs = this.diff_main(text1, text2, false, deadline);\r\n\r\n  // Convert the diff back to original text.\r\n  this.diff_charsToLines_(diffs, linearray);\r\n  // Eliminate freak matches (e.g. blank lines)\r\n  this.diff_cleanupSemantic(diffs);\r\n\r\n  // Rediff any replacement blocks, this time character-by-character.\r\n  // Add a dummy entry at the end.\r\n  diffs.push([DIFF_EQUAL, '']);\r\n  var pointer = 0;\r\n  var count_delete = 0;\r\n  var count_insert = 0;\r\n  var text_delete = '';\r\n  var text_insert = '';\r\n  while (pointer < diffs.length) {\r\n    switch (diffs[pointer][0]) {\r\n      case DIFF_INSERT:\r\n        count_insert++;\r\n        text_insert += diffs[pointer][1];\r\n        break;\r\n      case DIFF_DELETE:\r\n        count_delete++;\r\n        text_delete += diffs[pointer][1];\r\n        break;\r\n      case DIFF_EQUAL:\r\n        // Upon reaching an equality, check for prior redundancies.\r\n        if (count_delete >= 1 && count_insert >= 1) {\r\n          // Delete the offending records and add the merged ones.\r\n          diffs.splice(pointer - count_delete - count_insert,\r\n                       count_delete + count_insert);\r\n          pointer = pointer - count_delete - count_insert;\r\n          var a = this.diff_main(text_delete, text_insert, false, deadline);\r\n          for (var j = a.length - 1; j >= 0; j--) {\r\n            diffs.splice(pointer, 0, a[j]);\r\n          }\r\n          pointer = pointer + a.length;\r\n        }\r\n        count_insert = 0;\r\n        count_delete = 0;\r\n        text_delete = '';\r\n        text_insert = '';\r\n        break;\r\n    }\r\n    pointer++;\r\n  }\r\n  diffs.pop();  // Remove the dummy entry at the end.\r\n\r\n  return diffs;\r\n};\r\n\r\n\r\n/**\r\n * Find the 'middle snake' of a diff, split the problem in two\r\n * and return the recursively constructed diff.\r\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {number} deadline Time at which to bail if not yet complete.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\r\n  // Cache the text lengths to prevent multiple calls.\r\n  var text1_length = text1.length;\r\n  var text2_length = text2.length;\r\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\r\n  var v_offset = max_d;\r\n  var v_length = 2 * max_d;\r\n  var v1 = new Array(v_length);\r\n  var v2 = new Array(v_length);\r\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\r\n  // integers and undefined.\r\n  for (var x = 0; x < v_length; x++) {\r\n    v1[x] = -1;\r\n    v2[x] = -1;\r\n  }\r\n  v1[v_offset + 1] = 0;\r\n  v2[v_offset + 1] = 0;\r\n  var delta = text1_length - text2_length;\r\n  // If the total number of characters is odd, then the front path will collide\r\n  // with the reverse path.\r\n  var front = (delta % 2 != 0);\r\n  // Offsets for start and end of k loop.\r\n  // Prevents mapping of space beyond the grid.\r\n  var k1start = 0;\r\n  var k1end = 0;\r\n  var k2start = 0;\r\n  var k2end = 0;\r\n  for (var d = 0; d < max_d; d++) {\r\n    // Bail out if deadline is reached.\r\n    if ((new Date()).getTime() > deadline) {\r\n      break;\r\n    }\r\n\r\n    // Walk the front path one step.\r\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\r\n      var k1_offset = v_offset + k1;\r\n      var x1;\r\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\r\n        x1 = v1[k1_offset + 1];\r\n      } else {\r\n        x1 = v1[k1_offset - 1] + 1;\r\n      }\r\n      var y1 = x1 - k1;\r\n      while (x1 < text1_length && y1 < text2_length &&\r\n             text1.charAt(x1) == text2.charAt(y1)) {\r\n        x1++;\r\n        y1++;\r\n      }\r\n      v1[k1_offset] = x1;\r\n      if (x1 > text1_length) {\r\n        // Ran off the right of the graph.\r\n        k1end += 2;\r\n      } else if (y1 > text2_length) {\r\n        // Ran off the bottom of the graph.\r\n        k1start += 2;\r\n      } else if (front) {\r\n        var k2_offset = v_offset + delta - k1;\r\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\r\n          // Mirror x2 onto top-left coordinate system.\r\n          var x2 = text1_length - v2[k2_offset];\r\n          if (x1 >= x2) {\r\n            // Overlap detected.\r\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Walk the reverse path one step.\r\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\r\n      var k2_offset = v_offset + k2;\r\n      var x2;\r\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\r\n        x2 = v2[k2_offset + 1];\r\n      } else {\r\n        x2 = v2[k2_offset - 1] + 1;\r\n      }\r\n      var y2 = x2 - k2;\r\n      while (x2 < text1_length && y2 < text2_length &&\r\n             text1.charAt(text1_length - x2 - 1) ==\r\n             text2.charAt(text2_length - y2 - 1)) {\r\n        x2++;\r\n        y2++;\r\n      }\r\n      v2[k2_offset] = x2;\r\n      if (x2 > text1_length) {\r\n        // Ran off the left of the graph.\r\n        k2end += 2;\r\n      } else if (y2 > text2_length) {\r\n        // Ran off the top of the graph.\r\n        k2start += 2;\r\n      } else if (!front) {\r\n        var k1_offset = v_offset + delta - k2;\r\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\r\n          var x1 = v1[k1_offset];\r\n          var y1 = v_offset + x1 - k1_offset;\r\n          // Mirror x2 onto top-left coordinate system.\r\n          x2 = text1_length - x2;\r\n          if (x1 >= x2) {\r\n            // Overlap detected.\r\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Diff took too long and hit the deadline or\r\n  // number of diffs equals number of characters, no commonality at all.\r\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\r\n};\r\n\r\n\r\n/**\r\n * Given the location of the 'middle snake', split the diff in two parts\r\n * and recurse.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {number} x Index of split point in text1.\r\n * @param {number} y Index of split point in text2.\r\n * @param {number} deadline Time at which to bail if not yet complete.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\r\n    deadline) {\r\n  var text1a = text1.substring(0, x);\r\n  var text2a = text2.substring(0, y);\r\n  var text1b = text1.substring(x);\r\n  var text2b = text2.substring(y);\r\n\r\n  // Compute both diffs serially.\r\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\r\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\r\n\r\n  return diffs.concat(diffsb);\r\n};\r\n\r\n\r\n/**\r\n * Split two texts into an array of strings.  Reduce the texts to a string of\r\n * hashes where each Unicode character represents one line.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\r\n *     An object containing the encoded text1, the encoded text2 and\r\n *     the array of unique strings.\r\n *     The zeroth element of the array of unique strings is intentionally blank.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\r\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\r\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\r\n\r\n  // '\\x00' is a valid character, but various debuggers don't like it.\r\n  // So we'll insert a junk entry to avoid generating a null character.\r\n  lineArray[0] = '';\r\n\r\n  /**\r\n   * Split a text into an array of strings.  Reduce the texts to a string of\r\n   * hashes where each Unicode character represents one line.\r\n   * Modifies linearray and linehash through being a closure.\r\n   * @param {string} text String to encode.\r\n   * @return {string} Encoded string.\r\n   * @private\r\n   */\r\n  function diff_linesToCharsMunge_(text) {\r\n    var chars = '';\r\n    // Walk the text, pulling out a substring for each line.\r\n    // text.split('\\n') would would temporarily double our memory footprint.\r\n    // Modifying text would create many large strings to garbage collect.\r\n    var lineStart = 0;\r\n    var lineEnd = -1;\r\n    // Keeping our own length variable is faster than looking it up.\r\n    var lineArrayLength = lineArray.length;\r\n    while (lineEnd < text.length - 1) {\r\n      lineEnd = text.indexOf('\\n', lineStart);\r\n      if (lineEnd == -1) {\r\n        lineEnd = text.length - 1;\r\n      }\r\n      var line = text.substring(lineStart, lineEnd + 1);\r\n      lineStart = lineEnd + 1;\r\n\r\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\r\n          (lineHash[line] !== undefined)) {\r\n        chars += String.fromCharCode(lineHash[line]);\r\n      } else {\r\n        chars += String.fromCharCode(lineArrayLength);\r\n        lineHash[line] = lineArrayLength;\r\n        lineArray[lineArrayLength++] = line;\r\n      }\r\n    }\r\n    return chars;\r\n  }\r\n\r\n  var chars1 = diff_linesToCharsMunge_(text1);\r\n  var chars2 = diff_linesToCharsMunge_(text2);\r\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\r\n};\r\n\r\n\r\n/**\r\n * Rehydrate the text in a diff from a string of line hashes to real lines of\r\n * text.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @param {!Array.<string>} lineArray Array of unique strings.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var chars = diffs[x][1];\r\n    var text = [];\r\n    for (var y = 0; y < chars.length; y++) {\r\n      text[y] = lineArray[chars.charCodeAt(y)];\r\n    }\r\n    diffs[x][1] = text.join('');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Determine the common prefix of two strings.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {number} The number of characters common to the start of each\r\n *     string.\r\n */\r\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\r\n  // Quick check for common null cases.\r\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\r\n    return 0;\r\n  }\r\n  // Binary search.\r\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\r\n  var pointermin = 0;\r\n  var pointermax = Math.min(text1.length, text2.length);\r\n  var pointermid = pointermax;\r\n  var pointerstart = 0;\r\n  while (pointermin < pointermid) {\r\n    if (text1.substring(pointerstart, pointermid) ==\r\n        text2.substring(pointerstart, pointermid)) {\r\n      pointermin = pointermid;\r\n      pointerstart = pointermin;\r\n    } else {\r\n      pointermax = pointermid;\r\n    }\r\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\r\n  }\r\n  return pointermid;\r\n};\r\n\r\n\r\n/**\r\n * Determine the common suffix of two strings.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {number} The number of characters common to the end of each string.\r\n */\r\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\r\n  // Quick check for common null cases.\r\n  if (!text1 || !text2 ||\r\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\r\n    return 0;\r\n  }\r\n  // Binary search.\r\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\r\n  var pointermin = 0;\r\n  var pointermax = Math.min(text1.length, text2.length);\r\n  var pointermid = pointermax;\r\n  var pointerend = 0;\r\n  while (pointermin < pointermid) {\r\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\r\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\r\n      pointermin = pointermid;\r\n      pointerend = pointermin;\r\n    } else {\r\n      pointermax = pointermid;\r\n    }\r\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\r\n  }\r\n  return pointermid;\r\n};\r\n\r\n\r\n/**\r\n * Determine if the suffix of one string is the prefix of another.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {number} The number of characters common to the end of the first\r\n *     string and the start of the second string.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\r\n  // Cache the text lengths to prevent multiple calls.\r\n  var text1_length = text1.length;\r\n  var text2_length = text2.length;\r\n  // Eliminate the null case.\r\n  if (text1_length == 0 || text2_length == 0) {\r\n    return 0;\r\n  }\r\n  // Truncate the longer string.\r\n  if (text1_length > text2_length) {\r\n    text1 = text1.substring(text1_length - text2_length);\r\n  } else if (text1_length < text2_length) {\r\n    text2 = text2.substring(0, text1_length);\r\n  }\r\n  var text_length = Math.min(text1_length, text2_length);\r\n  // Quick check for the worst case.\r\n  if (text1 == text2) {\r\n    return text_length;\r\n  }\r\n\r\n  // Start by looking for a single character match\r\n  // and increase length until no match is found.\r\n  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\r\n  var best = 0;\r\n  var length = 1;\r\n  while (true) {\r\n    var pattern = text1.substring(text_length - length);\r\n    var found = text2.indexOf(pattern);\r\n    if (found == -1) {\r\n      return best;\r\n    }\r\n    length += found;\r\n    if (found == 0 || text1.substring(text_length - length) ==\r\n        text2.substring(0, length)) {\r\n      best = length;\r\n      length++;\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Do the two texts share a substring which is at least half the length of the\r\n * longer text?\r\n * This speedup can produce non-minimal diffs.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {Array.<string>} Five element Array, containing the prefix of\r\n *     text1, the suffix of text1, the prefix of text2, the suffix of\r\n *     text2 and the common middle.  Or null if there was no match.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\r\n  if (this.Diff_Timeout <= 0) {\r\n    // Don't risk returning a non-optimal diff if we have unlimited time.\r\n    return null;\r\n  }\r\n  var longtext = text1.length > text2.length ? text1 : text2;\r\n  var shorttext = text1.length > text2.length ? text2 : text1;\r\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\r\n    return null;  // Pointless.\r\n  }\r\n  var dmp = this;  // 'this' becomes 'window' in a closure.\r\n\r\n  /**\r\n   * Does a substring of shorttext exist within longtext such that the substring\r\n   * is at least half the length of longtext?\r\n   * Closure, but does not reference any external variables.\r\n   * @param {string} longtext Longer string.\r\n   * @param {string} shorttext Shorter string.\r\n   * @param {number} i Start index of quarter length substring within longtext.\r\n   * @return {Array.<string>} Five element Array, containing the prefix of\r\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\r\n   *     of shorttext and the common middle.  Or null if there was no match.\r\n   * @private\r\n   */\r\n  function diff_halfMatchI_(longtext, shorttext, i) {\r\n    // Start with a 1/4 length substring at position i as a seed.\r\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\r\n    var j = -1;\r\n    var best_common = '';\r\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\r\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\r\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\r\n                                               shorttext.substring(j));\r\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\r\n                                               shorttext.substring(0, j));\r\n      if (best_common.length < suffixLength + prefixLength) {\r\n        best_common = shorttext.substring(j - suffixLength, j) +\r\n            shorttext.substring(j, j + prefixLength);\r\n        best_longtext_a = longtext.substring(0, i - suffixLength);\r\n        best_longtext_b = longtext.substring(i + prefixLength);\r\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\r\n        best_shorttext_b = shorttext.substring(j + prefixLength);\r\n      }\r\n    }\r\n    if (best_common.length * 2 >= longtext.length) {\r\n      return [best_longtext_a, best_longtext_b,\r\n              best_shorttext_a, best_shorttext_b, best_common];\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // First check if the second quarter is the seed for a half-match.\r\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\r\n                             Math.ceil(longtext.length / 4));\r\n  // Check again based on the third quarter.\r\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\r\n                             Math.ceil(longtext.length / 2));\r\n  var hm;\r\n  if (!hm1 && !hm2) {\r\n    return null;\r\n  } else if (!hm2) {\r\n    hm = hm1;\r\n  } else if (!hm1) {\r\n    hm = hm2;\r\n  } else {\r\n    // Both matched.  Select the longest.\r\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\r\n  }\r\n\r\n  // A half-match was found, sort out the return data.\r\n  var text1_a, text1_b, text2_a, text2_b;\r\n  if (text1.length > text2.length) {\r\n    text1_a = hm[0];\r\n    text1_b = hm[1];\r\n    text2_a = hm[2];\r\n    text2_b = hm[3];\r\n  } else {\r\n    text2_a = hm[0];\r\n    text2_b = hm[1];\r\n    text1_a = hm[2];\r\n    text1_b = hm[3];\r\n  }\r\n  var mid_common = hm[4];\r\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\r\n};\r\n\r\n\r\n/**\r\n * Reduce the number of edits by eliminating semantically trivial equalities.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\r\n  var changes = false;\r\n  var equalities = [];  // Stack of indices where equalities are found.\r\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\r\n  /** @type {?string} */\r\n  var lastequality = null;\r\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n  var pointer = 0;  // Index of current position.\r\n  // Number of characters that changed prior to the equality.\r\n  var length_insertions1 = 0;\r\n  var length_deletions1 = 0;\r\n  // Number of characters that changed after the equality.\r\n  var length_insertions2 = 0;\r\n  var length_deletions2 = 0;\r\n  while (pointer < diffs.length) {\r\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\r\n      equalities[equalitiesLength++] = pointer;\r\n      length_insertions1 = length_insertions2;\r\n      length_deletions1 = length_deletions2;\r\n      length_insertions2 = 0;\r\n      length_deletions2 = 0;\r\n      lastequality = diffs[pointer][1];\r\n    } else {  // An insertion or deletion.\r\n      if (diffs[pointer][0] == DIFF_INSERT) {\r\n        length_insertions2 += diffs[pointer][1].length;\r\n      } else {\r\n        length_deletions2 += diffs[pointer][1].length;\r\n      }\r\n      // Eliminate an equality that is smaller or equal to the edits on both\r\n      // sides of it.\r\n      if (lastequality && (lastequality.length <=\r\n          Math.max(length_insertions1, length_deletions1)) &&\r\n          (lastequality.length <= Math.max(length_insertions2,\r\n                                           length_deletions2))) {\r\n        // Duplicate record.\r\n        diffs.splice(equalities[equalitiesLength - 1], 0,\r\n                     [DIFF_DELETE, lastequality]);\r\n        // Change second copy to insert.\r\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\r\n        // Throw away the equality we just deleted.\r\n        equalitiesLength--;\r\n        // Throw away the previous equality (it needs to be reevaluated).\r\n        equalitiesLength--;\r\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\r\n        length_insertions1 = 0;  // Reset the counters.\r\n        length_deletions1 = 0;\r\n        length_insertions2 = 0;\r\n        length_deletions2 = 0;\r\n        lastequality = null;\r\n        changes = true;\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n\r\n  // Normalize the diff.\r\n  if (changes) {\r\n    this.diff_cleanupMerge(diffs);\r\n  }\r\n  this.diff_cleanupSemanticLossless(diffs);\r\n\r\n  // Find any overlaps between deletions and insertions.\r\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\r\n  //   -> <del>abc</del>xxx<ins>def</ins>\r\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\r\n  //   -> <ins>def</ins>xxx<del>abc</del>\r\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\r\n  pointer = 1;\r\n  while (pointer < diffs.length) {\r\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\r\n        diffs[pointer][0] == DIFF_INSERT) {\r\n      var deletion = diffs[pointer - 1][1];\r\n      var insertion = diffs[pointer][1];\r\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\r\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\r\n      if (overlap_length1 >= overlap_length2) {\r\n        if (overlap_length1 >= deletion.length / 2 ||\r\n            overlap_length1 >= insertion.length / 2) {\r\n          // Overlap found.  Insert an equality and trim the surrounding edits.\r\n          diffs.splice(pointer, 0,\r\n              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);\r\n          diffs[pointer - 1][1] =\r\n              deletion.substring(0, deletion.length - overlap_length1);\r\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\r\n          pointer++;\r\n        }\r\n      } else {\r\n        if (overlap_length2 >= deletion.length / 2 ||\r\n            overlap_length2 >= insertion.length / 2) {\r\n          // Reverse overlap found.\r\n          // Insert an equality and swap and trim the surrounding edits.\r\n          diffs.splice(pointer, 0,\r\n              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);\r\n          diffs[pointer - 1][0] = DIFF_INSERT;\r\n          diffs[pointer - 1][1] =\r\n              insertion.substring(0, insertion.length - overlap_length2);\r\n          diffs[pointer + 1][0] = DIFF_DELETE;\r\n          diffs[pointer + 1][1] =\r\n              deletion.substring(overlap_length2);\r\n          pointer++;\r\n        }\r\n      }\r\n      pointer++;\r\n    }\r\n    pointer++;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Look for single edits surrounded on both sides by equalities\r\n * which can be shifted sideways to align the edit to a word boundary.\r\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\r\n  /**\r\n   * Given two strings, compute a score representing whether the internal\r\n   * boundary falls on logical boundaries.\r\n   * Scores range from 6 (best) to 0 (worst).\r\n   * Closure, but does not reference any external variables.\r\n   * @param {string} one First string.\r\n   * @param {string} two Second string.\r\n   * @return {number} The score.\r\n   * @private\r\n   */\r\n  function diff_cleanupSemanticScore_(one, two) {\r\n    if (!one || !two) {\r\n      // Edges are the best.\r\n      return 6;\r\n    }\r\n\r\n    // Each port of this function behaves slightly differently due to\r\n    // subtle differences in each language's definition of things like\r\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\r\n    // the choice has been made to use each language's native features\r\n    // rather than force total conformity.\r\n    var char1 = one.charAt(one.length - 1);\r\n    var char2 = two.charAt(0);\r\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\r\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\r\n    var whitespace1 = nonAlphaNumeric1 &&\r\n        char1.match(diff_match_patch.whitespaceRegex_);\r\n    var whitespace2 = nonAlphaNumeric2 &&\r\n        char2.match(diff_match_patch.whitespaceRegex_);\r\n    var lineBreak1 = whitespace1 &&\r\n        char1.match(diff_match_patch.linebreakRegex_);\r\n    var lineBreak2 = whitespace2 &&\r\n        char2.match(diff_match_patch.linebreakRegex_);\r\n    var blankLine1 = lineBreak1 &&\r\n        one.match(diff_match_patch.blanklineEndRegex_);\r\n    var blankLine2 = lineBreak2 &&\r\n        two.match(diff_match_patch.blanklineStartRegex_);\r\n\r\n    if (blankLine1 || blankLine2) {\r\n      // Five points for blank lines.\r\n      return 5;\r\n    } else if (lineBreak1 || lineBreak2) {\r\n      // Four points for line breaks.\r\n      return 4;\r\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\r\n      // Three points for end of sentences.\r\n      return 3;\r\n    } else if (whitespace1 || whitespace2) {\r\n      // Two points for whitespace.\r\n      return 2;\r\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\r\n      // One point for non-alphanumeric.\r\n      return 1;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  var pointer = 1;\r\n  // Intentionally ignore the first and last element (don't need checking).\r\n  while (pointer < diffs.length - 1) {\r\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\r\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\r\n      // This is a single edit surrounded by equalities.\r\n      var equality1 = diffs[pointer - 1][1];\r\n      var edit = diffs[pointer][1];\r\n      var equality2 = diffs[pointer + 1][1];\r\n\r\n      // First, shift the edit as far left as possible.\r\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\r\n      if (commonOffset) {\r\n        var commonString = edit.substring(edit.length - commonOffset);\r\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\r\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\r\n        equality2 = commonString + equality2;\r\n      }\r\n\r\n      // Second, step character by character right, looking for the best fit.\r\n      var bestEquality1 = equality1;\r\n      var bestEdit = edit;\r\n      var bestEquality2 = equality2;\r\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\r\n          diff_cleanupSemanticScore_(edit, equality2);\r\n      while (edit.charAt(0) === equality2.charAt(0)) {\r\n        equality1 += edit.charAt(0);\r\n        edit = edit.substring(1) + equality2.charAt(0);\r\n        equality2 = equality2.substring(1);\r\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\r\n            diff_cleanupSemanticScore_(edit, equality2);\r\n        // The >= encourages trailing rather than leading whitespace on edits.\r\n        if (score >= bestScore) {\r\n          bestScore = score;\r\n          bestEquality1 = equality1;\r\n          bestEdit = edit;\r\n          bestEquality2 = equality2;\r\n        }\r\n      }\r\n\r\n      if (diffs[pointer - 1][1] != bestEquality1) {\r\n        // We have an improvement, save it back to the diff.\r\n        if (bestEquality1) {\r\n          diffs[pointer - 1][1] = bestEquality1;\r\n        } else {\r\n          diffs.splice(pointer - 1, 1);\r\n          pointer--;\r\n        }\r\n        diffs[pointer][1] = bestEdit;\r\n        if (bestEquality2) {\r\n          diffs[pointer + 1][1] = bestEquality2;\r\n        } else {\r\n          diffs.splice(pointer + 1, 1);\r\n          pointer--;\r\n        }\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n};\r\n\r\n// Define some regex patterns for matching boundaries.\r\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\r\ndiff_match_patch.whitespaceRegex_ = /\\s/;\r\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\r\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\r\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\r\n\r\n/**\r\n * Reduce the number of edits by eliminating operationally trivial equalities.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\r\n  var changes = false;\r\n  var equalities = [];  // Stack of indices where equalities are found.\r\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\r\n  /** @type {?string} */\r\n  var lastequality = null;\r\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n  var pointer = 0;  // Index of current position.\r\n  // Is there an insertion operation before the last equality.\r\n  var pre_ins = false;\r\n  // Is there a deletion operation before the last equality.\r\n  var pre_del = false;\r\n  // Is there an insertion operation after the last equality.\r\n  var post_ins = false;\r\n  // Is there a deletion operation after the last equality.\r\n  var post_del = false;\r\n  while (pointer < diffs.length) {\r\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\r\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\r\n          (post_ins || post_del)) {\r\n        // Candidate found.\r\n        equalities[equalitiesLength++] = pointer;\r\n        pre_ins = post_ins;\r\n        pre_del = post_del;\r\n        lastequality = diffs[pointer][1];\r\n      } else {\r\n        // Not a candidate, and can never become one.\r\n        equalitiesLength = 0;\r\n        lastequality = null;\r\n      }\r\n      post_ins = post_del = false;\r\n    } else {  // An insertion or deletion.\r\n      if (diffs[pointer][0] == DIFF_DELETE) {\r\n        post_del = true;\r\n      } else {\r\n        post_ins = true;\r\n      }\r\n      /*\r\n       * Five types to be split:\r\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\r\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\r\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\r\n       * <ins>A</del>X<ins>C</ins><del>D</del>\r\n       * <ins>A</ins><del>B</del>X<del>C</del>\r\n       */\r\n      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\r\n                           ((lastequality.length < this.Diff_EditCost / 2) &&\r\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\r\n        // Duplicate record.\r\n        diffs.splice(equalities[equalitiesLength - 1], 0,\r\n                     [DIFF_DELETE, lastequality]);\r\n        // Change second copy to insert.\r\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\r\n        equalitiesLength--;  // Throw away the equality we just deleted;\r\n        lastequality = null;\r\n        if (pre_ins && pre_del) {\r\n          // No changes made which could affect previous entry, keep going.\r\n          post_ins = post_del = true;\r\n          equalitiesLength = 0;\r\n        } else {\r\n          equalitiesLength--;  // Throw away the previous equality.\r\n          pointer = equalitiesLength > 0 ?\r\n              equalities[equalitiesLength - 1] : -1;\r\n          post_ins = post_del = false;\r\n        }\r\n        changes = true;\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n\r\n  if (changes) {\r\n    this.diff_cleanupMerge(diffs);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Reorder and merge like edit sections.  Merge equalities.\r\n * Any edit section can move as long as it doesn't cross an equality.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\r\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\r\n  var pointer = 0;\r\n  var count_delete = 0;\r\n  var count_insert = 0;\r\n  var text_delete = '';\r\n  var text_insert = '';\r\n  var commonlength;\r\n  while (pointer < diffs.length) {\r\n    switch (diffs[pointer][0]) {\r\n      case DIFF_INSERT:\r\n        count_insert++;\r\n        text_insert += diffs[pointer][1];\r\n        pointer++;\r\n        break;\r\n      case DIFF_DELETE:\r\n        count_delete++;\r\n        text_delete += diffs[pointer][1];\r\n        pointer++;\r\n        break;\r\n      case DIFF_EQUAL:\r\n        // Upon reaching an equality, check for prior redundancies.\r\n        if (count_delete + count_insert > 1) {\r\n          if (count_delete !== 0 && count_insert !== 0) {\r\n            // Factor out any common prefixies.\r\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\r\n            if (commonlength !== 0) {\r\n              if ((pointer - count_delete - count_insert) > 0 &&\r\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\r\n                  DIFF_EQUAL) {\r\n                diffs[pointer - count_delete - count_insert - 1][1] +=\r\n                    text_insert.substring(0, commonlength);\r\n              } else {\r\n                diffs.splice(0, 0, [DIFF_EQUAL,\r\n                                    text_insert.substring(0, commonlength)]);\r\n                pointer++;\r\n              }\r\n              text_insert = text_insert.substring(commonlength);\r\n              text_delete = text_delete.substring(commonlength);\r\n            }\r\n            // Factor out any common suffixies.\r\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\r\n            if (commonlength !== 0) {\r\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\r\n                  commonlength) + diffs[pointer][1];\r\n              text_insert = text_insert.substring(0, text_insert.length -\r\n                  commonlength);\r\n              text_delete = text_delete.substring(0, text_delete.length -\r\n                  commonlength);\r\n            }\r\n          }\r\n          // Delete the offending records and add the merged ones.\r\n          if (count_delete === 0) {\r\n            diffs.splice(pointer - count_insert,\r\n                count_delete + count_insert, [DIFF_INSERT, text_insert]);\r\n          } else if (count_insert === 0) {\r\n            diffs.splice(pointer - count_delete,\r\n                count_delete + count_insert, [DIFF_DELETE, text_delete]);\r\n          } else {\r\n            diffs.splice(pointer - count_delete - count_insert,\r\n                count_delete + count_insert, [DIFF_DELETE, text_delete],\r\n                [DIFF_INSERT, text_insert]);\r\n          }\r\n          pointer = pointer - count_delete - count_insert +\r\n                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\r\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\r\n          // Merge this equality with the previous one.\r\n          diffs[pointer - 1][1] += diffs[pointer][1];\r\n          diffs.splice(pointer, 1);\r\n        } else {\r\n          pointer++;\r\n        }\r\n        count_insert = 0;\r\n        count_delete = 0;\r\n        text_delete = '';\r\n        text_insert = '';\r\n        break;\r\n    }\r\n  }\r\n  if (diffs[diffs.length - 1][1] === '') {\r\n    diffs.pop();  // Remove the dummy entry at the end.\r\n  }\r\n\r\n  // Second pass: look for single edits surrounded on both sides by equalities\r\n  // which can be shifted sideways to eliminate an equality.\r\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\r\n  var changes = false;\r\n  pointer = 1;\r\n  // Intentionally ignore the first and last element (don't need checking).\r\n  while (pointer < diffs.length - 1) {\r\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\r\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\r\n      // This is a single edit surrounded by equalities.\r\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\r\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\r\n        // Shift the edit over the previous equality.\r\n        diffs[pointer][1] = diffs[pointer - 1][1] +\r\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\r\n                                        diffs[pointer - 1][1].length);\r\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\r\n        diffs.splice(pointer - 1, 1);\r\n        changes = true;\r\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\r\n          diffs[pointer + 1][1]) {\r\n        // Shift the edit over the next equality.\r\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\r\n        diffs[pointer][1] =\r\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\r\n            diffs[pointer + 1][1];\r\n        diffs.splice(pointer + 1, 1);\r\n        changes = true;\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n  // If shifts were made, the diff needs reordering and another shift sweep.\r\n  if (changes) {\r\n    this.diff_cleanupMerge(diffs);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * loc is a location in text1, compute and return the equivalent location in\r\n * text2.\r\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @param {number} loc Location within text1.\r\n * @return {number} Location within text2.\r\n */\r\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\r\n  var chars1 = 0;\r\n  var chars2 = 0;\r\n  var last_chars1 = 0;\r\n  var last_chars2 = 0;\r\n  var x;\r\n  for (x = 0; x < diffs.length; x++) {\r\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\r\n      chars1 += diffs[x][1].length;\r\n    }\r\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\r\n      chars2 += diffs[x][1].length;\r\n    }\r\n    if (chars1 > loc) {  // Overshot the location.\r\n      break;\r\n    }\r\n    last_chars1 = chars1;\r\n    last_chars2 = chars2;\r\n  }\r\n  // Was the location was deleted?\r\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\r\n    return last_chars2;\r\n  }\r\n  // Add the remaining character length.\r\n  return last_chars2 + (loc - last_chars1);\r\n};\r\n\r\n\r\n/**\r\n * Convert a diff array into a pretty HTML report.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} HTML representation.\r\n */\r\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\r\n  var html = [];\r\n  var pattern_amp = /&/g;\r\n  var pattern_lt = /</g;\r\n  var pattern_gt = />/g;\r\n  var pattern_para = /\\n/g;\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\r\n    var data = diffs[x][1];  // Text of change.\r\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\r\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\r\n    switch (op) {\r\n      case DIFF_INSERT:\r\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\r\n        break;\r\n      case DIFF_DELETE:\r\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\r\n        break;\r\n      case DIFF_EQUAL:\r\n        html[x] = '<span>' + text + '</span>';\r\n        break;\r\n    }\r\n  }\r\n  return html.join('');\r\n};\r\n\r\n\r\n/**\r\n * Compute and return the source text (all equalities and deletions).\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} Source text.\r\n */\r\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\r\n  var text = [];\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    if (diffs[x][0] !== DIFF_INSERT) {\r\n      text[x] = diffs[x][1];\r\n    }\r\n  }\r\n  return text.join('');\r\n};\r\n\r\n\r\n/**\r\n * Compute and return the destination text (all equalities and insertions).\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} Destination text.\r\n */\r\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\r\n  var text = [];\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    if (diffs[x][0] !== DIFF_DELETE) {\r\n      text[x] = diffs[x][1];\r\n    }\r\n  }\r\n  return text.join('');\r\n};\r\n\r\n\r\n/**\r\n * Compute the Levenshtein distance; the number of inserted, deleted or\r\n * substituted characters.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {number} Number of changes.\r\n */\r\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\r\n  var levenshtein = 0;\r\n  var insertions = 0;\r\n  var deletions = 0;\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var op = diffs[x][0];\r\n    var data = diffs[x][1];\r\n    switch (op) {\r\n      case DIFF_INSERT:\r\n        insertions += data.length;\r\n        break;\r\n      case DIFF_DELETE:\r\n        deletions += data.length;\r\n        break;\r\n      case DIFF_EQUAL:\r\n        // A deletion and an insertion is one substitution.\r\n        levenshtein += Math.max(insertions, deletions);\r\n        insertions = 0;\r\n        deletions = 0;\r\n        break;\r\n    }\r\n  }\r\n  levenshtein += Math.max(insertions, deletions);\r\n  return levenshtein;\r\n};\r\n\r\n\r\n/**\r\n * Crush the diff into an encoded string which describes the operations\r\n * required to transform text1 into text2.\r\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\r\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} Delta text.\r\n */\r\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\r\n  var text = [];\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    switch (diffs[x][0]) {\r\n      case DIFF_INSERT:\r\n        text[x] = '+' + encodeURI(diffs[x][1]);\r\n        break;\r\n      case DIFF_DELETE:\r\n        text[x] = '-' + diffs[x][1].length;\r\n        break;\r\n      case DIFF_EQUAL:\r\n        text[x] = '=' + diffs[x][1].length;\r\n        break;\r\n    }\r\n  }\r\n  return text.join('\\t').replace(/%20/g, ' ');\r\n};\r\n\r\n\r\n/**\r\n * Given the original text1, and an encoded string which describes the\r\n * operations required to transform text1 into text2, compute the full diff.\r\n * @param {string} text1 Source string for the diff.\r\n * @param {string} delta Delta text.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @throws {!Error} If invalid input.\r\n */\r\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\r\n  var diffs = [];\r\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\r\n  var pointer = 0;  // Cursor in text1\r\n  var tokens = delta.split(/\\t/g);\r\n  for (var x = 0; x < tokens.length; x++) {\r\n    // Each token begins with a one character parameter which specifies the\r\n    // operation of this token (delete, insert, equality).\r\n    var param = tokens[x].substring(1);\r\n    switch (tokens[x].charAt(0)) {\r\n      case '+':\r\n        try {\r\n          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\r\n        } catch (ex) {\r\n          // Malformed URI sequence.\r\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\r\n        }\r\n        break;\r\n      case '-':\r\n        // Fall through.\r\n      case '=':\r\n        var n = parseInt(param, 10);\r\n        if (isNaN(n) || n < 0) {\r\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\r\n        }\r\n        var text = text1.substring(pointer, pointer += n);\r\n        if (tokens[x].charAt(0) == '=') {\r\n          diffs[diffsLength++] = [DIFF_EQUAL, text];\r\n        } else {\r\n          diffs[diffsLength++] = [DIFF_DELETE, text];\r\n        }\r\n        break;\r\n      default:\r\n        // Blank tokens are ok (from a trailing \\t).\r\n        // Anything else is an error.\r\n        if (tokens[x]) {\r\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\r\n                          tokens[x]);\r\n        }\r\n    }\r\n  }\r\n  if (pointer != text1.length) {\r\n    throw new Error('Delta length (' + pointer +\r\n        ') does not equal source text length (' + text1.length + ').');\r\n  }\r\n  return diffs;\r\n};\r\n\r\n\r\n//  MATCH FUNCTIONS\r\n\r\n\r\n/**\r\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\r\n * @param {string} text The text to search.\r\n * @param {string} pattern The pattern to search for.\r\n * @param {number} loc The location to search around.\r\n * @return {number} Best match index or -1.\r\n */\r\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\r\n  // Check for null inputs.\r\n  if (text == null || pattern == null || loc == null) {\r\n    throw new Error('Null input. (match_main)');\r\n  }\r\n\r\n  loc = Math.max(0, Math.min(loc, text.length));\r\n  if (text == pattern) {\r\n    // Shortcut (potentially not guaranteed by the algorithm)\r\n    return 0;\r\n  } else if (!text.length) {\r\n    // Nothing to match.\r\n    return -1;\r\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\r\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\r\n    return loc;\r\n  } else {\r\n    // Do a fuzzy compare.\r\n    return this.match_bitap_(text, pattern, loc);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\r\n * Bitap algorithm.\r\n * @param {string} text The text to search.\r\n * @param {string} pattern The pattern to search for.\r\n * @param {number} loc The location to search around.\r\n * @return {number} Best match index or -1.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\r\n  if (pattern.length > this.Match_MaxBits) {\r\n    throw new Error('Pattern too long for this browser.');\r\n  }\r\n\r\n  // Initialise the alphabet.\r\n  var s = this.match_alphabet_(pattern);\r\n\r\n  var dmp = this;  // 'this' becomes 'window' in a closure.\r\n\r\n  /**\r\n   * Compute and return the score for a match with e errors and x location.\r\n   * Accesses loc and pattern through being a closure.\r\n   * @param {number} e Number of errors in match.\r\n   * @param {number} x Location of match.\r\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\r\n   * @private\r\n   */\r\n  function match_bitapScore_(e, x) {\r\n    var accuracy = e / pattern.length;\r\n    var proximity = Math.abs(loc - x);\r\n    if (!dmp.Match_Distance) {\r\n      // Dodge divide by zero error.\r\n      return proximity ? 1.0 : accuracy;\r\n    }\r\n    return accuracy + (proximity / dmp.Match_Distance);\r\n  }\r\n\r\n  // Highest score beyond which we give up.\r\n  var score_threshold = this.Match_Threshold;\r\n  // Is there a nearby exact match? (speedup)\r\n  var best_loc = text.indexOf(pattern, loc);\r\n  if (best_loc != -1) {\r\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\r\n    // What about in the other direction? (speedup)\r\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\r\n    if (best_loc != -1) {\r\n      score_threshold =\r\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\r\n    }\r\n  }\r\n\r\n  // Initialise the bit arrays.\r\n  var matchmask = 1 << (pattern.length - 1);\r\n  best_loc = -1;\r\n\r\n  var bin_min, bin_mid;\r\n  var bin_max = pattern.length + text.length;\r\n  var last_rd;\r\n  for (var d = 0; d < pattern.length; d++) {\r\n    // Scan for the best match; each iteration allows for one more error.\r\n    // Run a binary search to determine how far from 'loc' we can stray at this\r\n    // error level.\r\n    bin_min = 0;\r\n    bin_mid = bin_max;\r\n    while (bin_min < bin_mid) {\r\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\r\n        bin_min = bin_mid;\r\n      } else {\r\n        bin_max = bin_mid;\r\n      }\r\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\r\n    }\r\n    // Use the result from this iteration as the maximum for the next.\r\n    bin_max = bin_mid;\r\n    var start = Math.max(1, loc - bin_mid + 1);\r\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\r\n\r\n    var rd = Array(finish + 2);\r\n    rd[finish + 1] = (1 << d) - 1;\r\n    for (var j = finish; j >= start; j--) {\r\n      // The alphabet (s) is a sparse hash, so the following line generates\r\n      // warnings.\r\n      var charMatch = s[text.charAt(j - 1)];\r\n      if (d === 0) {  // First pass: exact match.\r\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\r\n      } else {  // Subsequent passes: fuzzy match.\r\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\r\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\r\n                last_rd[j + 1];\r\n      }\r\n      if (rd[j] & matchmask) {\r\n        var score = match_bitapScore_(d, j - 1);\r\n        // This match will almost certainly be better than any existing match.\r\n        // But check anyway.\r\n        if (score <= score_threshold) {\r\n          // Told you so.\r\n          score_threshold = score;\r\n          best_loc = j - 1;\r\n          if (best_loc > loc) {\r\n            // When passing loc, don't exceed our current distance from loc.\r\n            start = Math.max(1, 2 * loc - best_loc);\r\n          } else {\r\n            // Already passed loc, downhill from here on in.\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // No hope for a (better) match at greater error levels.\r\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\r\n      break;\r\n    }\r\n    last_rd = rd;\r\n  }\r\n  return best_loc;\r\n};\r\n\r\n\r\n/**\r\n * Initialise the alphabet for the Bitap algorithm.\r\n * @param {string} pattern The text to encode.\r\n * @return {!Object} Hash of character locations.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\r\n  var s = {};\r\n  for (var i = 0; i < pattern.length; i++) {\r\n    s[pattern.charAt(i)] = 0;\r\n  }\r\n  for (var i = 0; i < pattern.length; i++) {\r\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\r\n  }\r\n  return s;\r\n};\r\n\r\n\r\n//  PATCH FUNCTIONS\r\n\r\n\r\n/**\r\n * Increase the context until it is unique,\r\n * but don't let the pattern expand beyond Match_MaxBits.\r\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\r\n * @param {string} text Source text.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\r\n  if (text.length == 0) {\r\n    return;\r\n  }\r\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\r\n  var padding = 0;\r\n\r\n  // Look for the first and last matches of pattern in text.  If two different\r\n  // matches are found, increase the pattern length.\r\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\r\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\r\n         this.Patch_Margin) {\r\n    padding += this.Patch_Margin;\r\n    pattern = text.substring(patch.start2 - padding,\r\n                             patch.start2 + patch.length1 + padding);\r\n  }\r\n  // Add one chunk for good luck.\r\n  padding += this.Patch_Margin;\r\n\r\n  // Add the prefix.\r\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\r\n  if (prefix) {\r\n    patch.diffs.unshift([DIFF_EQUAL, prefix]);\r\n  }\r\n  // Add the suffix.\r\n  var suffix = text.substring(patch.start2 + patch.length1,\r\n                              patch.start2 + patch.length1 + padding);\r\n  if (suffix) {\r\n    patch.diffs.push([DIFF_EQUAL, suffix]);\r\n  }\r\n\r\n  // Roll back the start points.\r\n  patch.start1 -= prefix.length;\r\n  patch.start2 -= prefix.length;\r\n  // Extend the lengths.\r\n  patch.length1 += prefix.length + suffix.length;\r\n  patch.length2 += prefix.length + suffix.length;\r\n};\r\n\r\n\r\n/**\r\n * Compute a list of patches to turn text1 into text2.\r\n * Use diffs if provided, otherwise compute it ourselves.\r\n * There are four ways to call this function, depending on what data is\r\n * available to the caller:\r\n * Method 1:\r\n * a = text1, b = text2\r\n * Method 2:\r\n * a = diffs\r\n * Method 3 (optimal):\r\n * a = text1, b = diffs\r\n * Method 4 (deprecated, use method 3):\r\n * a = text1, b = text2, c = diffs\r\n *\r\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\r\n * Array of diff tuples for text1 to text2 (method 2).\r\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or\r\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\r\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples\r\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\r\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n */\r\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\r\n  var text1, diffs;\r\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\r\n      typeof opt_c == 'undefined') {\r\n    // Method 1: text1, text2\r\n    // Compute diffs from text1 and text2.\r\n    text1 = /** @type {string} */(a);\r\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\r\n    if (diffs.length > 2) {\r\n      this.diff_cleanupSemantic(diffs);\r\n      this.diff_cleanupEfficiency(diffs);\r\n    }\r\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\r\n      typeof opt_c == 'undefined') {\r\n    // Method 2: diffs\r\n    // Compute text1 from diffs.\r\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\r\n    text1 = this.diff_text1(diffs);\r\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\r\n      typeof opt_c == 'undefined') {\r\n    // Method 3: text1, diffs\r\n    text1 = /** @type {string} */(a);\r\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\r\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\r\n      opt_c && typeof opt_c == 'object') {\r\n    // Method 4: text1, text2, diffs\r\n    // text2 is not used.\r\n    text1 = /** @type {string} */(a);\r\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\r\n  } else {\r\n    throw new Error('Unknown call format to patch_make.');\r\n  }\r\n\r\n  if (diffs.length === 0) {\r\n    return [];  // Get rid of the null case.\r\n  }\r\n  var patches = [];\r\n  var patch = new diff_match_patch.patch_obj();\r\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\r\n  var char_count1 = 0;  // Number of characters into the text1 string.\r\n  var char_count2 = 0;  // Number of characters into the text2 string.\r\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\r\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\r\n  // context info.\r\n  var prepatch_text = text1;\r\n  var postpatch_text = text1;\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var diff_type = diffs[x][0];\r\n    var diff_text = diffs[x][1];\r\n\r\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\r\n      // A new patch starts here.\r\n      patch.start1 = char_count1;\r\n      patch.start2 = char_count2;\r\n    }\r\n\r\n    switch (diff_type) {\r\n      case DIFF_INSERT:\r\n        patch.diffs[patchDiffLength++] = diffs[x];\r\n        patch.length2 += diff_text.length;\r\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\r\n                         postpatch_text.substring(char_count2);\r\n        break;\r\n      case DIFF_DELETE:\r\n        patch.length1 += diff_text.length;\r\n        patch.diffs[patchDiffLength++] = diffs[x];\r\n        postpatch_text = postpatch_text.substring(0, char_count2) +\r\n                         postpatch_text.substring(char_count2 +\r\n                             diff_text.length);\r\n        break;\r\n      case DIFF_EQUAL:\r\n        if (diff_text.length <= 2 * this.Patch_Margin &&\r\n            patchDiffLength && diffs.length != x + 1) {\r\n          // Small equality inside a patch.\r\n          patch.diffs[patchDiffLength++] = diffs[x];\r\n          patch.length1 += diff_text.length;\r\n          patch.length2 += diff_text.length;\r\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\r\n          // Time for a new patch.\r\n          if (patchDiffLength) {\r\n            this.patch_addContext_(patch, prepatch_text);\r\n            patches.push(patch);\r\n            patch = new diff_match_patch.patch_obj();\r\n            patchDiffLength = 0;\r\n            // Unlike Unidiff, our patch lists have a rolling context.\r\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\r\n            // Update prepatch text & pos to reflect the application of the\r\n            // just completed patch.\r\n            prepatch_text = postpatch_text;\r\n            char_count1 = char_count2;\r\n          }\r\n        }\r\n        break;\r\n    }\r\n\r\n    // Update the current character count.\r\n    if (diff_type !== DIFF_INSERT) {\r\n      char_count1 += diff_text.length;\r\n    }\r\n    if (diff_type !== DIFF_DELETE) {\r\n      char_count2 += diff_text.length;\r\n    }\r\n  }\r\n  // Pick up the leftover patch if not empty.\r\n  if (patchDiffLength) {\r\n    this.patch_addContext_(patch, prepatch_text);\r\n    patches.push(patch);\r\n  }\r\n\r\n  return patches;\r\n};\r\n\r\n\r\n/**\r\n * Given an array of patches, return another array that is identical.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n */\r\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\r\n  // Making deep copies is hard in JavaScript.\r\n  var patchesCopy = [];\r\n  for (var x = 0; x < patches.length; x++) {\r\n    var patch = patches[x];\r\n    var patchCopy = new diff_match_patch.patch_obj();\r\n    patchCopy.diffs = [];\r\n    for (var y = 0; y < patch.diffs.length; y++) {\r\n      patchCopy.diffs[y] = patch.diffs[y].slice();\r\n    }\r\n    patchCopy.start1 = patch.start1;\r\n    patchCopy.start2 = patch.start2;\r\n    patchCopy.length1 = patch.length1;\r\n    patchCopy.length2 = patch.length2;\r\n    patchesCopy[x] = patchCopy;\r\n  }\r\n  return patchesCopy;\r\n};\r\n\r\n\r\n/**\r\n * Merge a set of patches onto the text.  Return a patched text, as well\r\n * as a list of true/false values indicating which patches were applied.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @param {string} text Old text.\r\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\r\n *      new text and an array of boolean values.\r\n */\r\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\r\n  if (patches.length == 0) {\r\n    return [text, []];\r\n  }\r\n\r\n  // Deep copy the patches so that no changes are made to originals.\r\n  patches = this.patch_deepCopy(patches);\r\n\r\n  var nullPadding = this.patch_addPadding(patches);\r\n  text = nullPadding + text + nullPadding;\r\n\r\n  this.patch_splitMax(patches);\r\n  // delta keeps track of the offset between the expected and actual location\r\n  // of the previous patch.  If there are patches expected at positions 10 and\r\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\r\n  // has an effective expected position of 22.\r\n  var delta = 0;\r\n  var results = [];\r\n  for (var x = 0; x < patches.length; x++) {\r\n    var expected_loc = patches[x].start2 + delta;\r\n    var text1 = this.diff_text1(patches[x].diffs);\r\n    var start_loc;\r\n    var end_loc = -1;\r\n    if (text1.length > this.Match_MaxBits) {\r\n      // patch_splitMax will only provide an oversized pattern in the case of\r\n      // a monster delete.\r\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\r\n                                  expected_loc);\r\n      if (start_loc != -1) {\r\n        end_loc = this.match_main(text,\r\n            text1.substring(text1.length - this.Match_MaxBits),\r\n            expected_loc + text1.length - this.Match_MaxBits);\r\n        if (end_loc == -1 || start_loc >= end_loc) {\r\n          // Can't find valid trailing context.  Drop this patch.\r\n          start_loc = -1;\r\n        }\r\n      }\r\n    } else {\r\n      start_loc = this.match_main(text, text1, expected_loc);\r\n    }\r\n    if (start_loc == -1) {\r\n      // No match found.  :(\r\n      results[x] = false;\r\n      // Subtract the delta for this failed patch from subsequent patches.\r\n      delta -= patches[x].length2 - patches[x].length1;\r\n    } else {\r\n      // Found a match.  :)\r\n      results[x] = true;\r\n      delta = start_loc - expected_loc;\r\n      var text2;\r\n      if (end_loc == -1) {\r\n        text2 = text.substring(start_loc, start_loc + text1.length);\r\n      } else {\r\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\r\n      }\r\n      if (text1 == text2) {\r\n        // Perfect match, just shove the replacement text in.\r\n        text = text.substring(0, start_loc) +\r\n               this.diff_text2(patches[x].diffs) +\r\n               text.substring(start_loc + text1.length);\r\n      } else {\r\n        // Imperfect match.  Run a diff to get a framework of equivalent\r\n        // indices.\r\n        var diffs = this.diff_main(text1, text2, false);\r\n        if (text1.length > this.Match_MaxBits &&\r\n            this.diff_levenshtein(diffs) / text1.length >\r\n            this.Patch_DeleteThreshold) {\r\n          // The end points match, but the content is unacceptably bad.\r\n          results[x] = false;\r\n        } else {\r\n          this.diff_cleanupSemanticLossless(diffs);\r\n          var index1 = 0;\r\n          var index2;\r\n          for (var y = 0; y < patches[x].diffs.length; y++) {\r\n            var mod = patches[x].diffs[y];\r\n            if (mod[0] !== DIFF_EQUAL) {\r\n              index2 = this.diff_xIndex(diffs, index1);\r\n            }\r\n            if (mod[0] === DIFF_INSERT) {  // Insertion\r\n              text = text.substring(0, start_loc + index2) + mod[1] +\r\n                     text.substring(start_loc + index2);\r\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\r\n              text = text.substring(0, start_loc + index2) +\r\n                     text.substring(start_loc + this.diff_xIndex(diffs,\r\n                         index1 + mod[1].length));\r\n            }\r\n            if (mod[0] !== DIFF_DELETE) {\r\n              index1 += mod[1].length;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Strip the padding off.\r\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\r\n  return [text, results];\r\n};\r\n\r\n\r\n/**\r\n * Add some padding on text start and end so that edges can match something.\r\n * Intended to be called only from within patch_apply.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @return {string} The padding string added to each side.\r\n */\r\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\r\n  var paddingLength = this.Patch_Margin;\r\n  var nullPadding = '';\r\n  for (var x = 1; x <= paddingLength; x++) {\r\n    nullPadding += String.fromCharCode(x);\r\n  }\r\n\r\n  // Bump all the patches forward.\r\n  for (var x = 0; x < patches.length; x++) {\r\n    patches[x].start1 += paddingLength;\r\n    patches[x].start2 += paddingLength;\r\n  }\r\n\r\n  // Add some padding on start of first diff.\r\n  var patch = patches[0];\r\n  var diffs = patch.diffs;\r\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\r\n    // Add nullPadding equality.\r\n    diffs.unshift([DIFF_EQUAL, nullPadding]);\r\n    patch.start1 -= paddingLength;  // Should be 0.\r\n    patch.start2 -= paddingLength;  // Should be 0.\r\n    patch.length1 += paddingLength;\r\n    patch.length2 += paddingLength;\r\n  } else if (paddingLength > diffs[0][1].length) {\r\n    // Grow first equality.\r\n    var extraLength = paddingLength - diffs[0][1].length;\r\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\r\n    patch.start1 -= extraLength;\r\n    patch.start2 -= extraLength;\r\n    patch.length1 += extraLength;\r\n    patch.length2 += extraLength;\r\n  }\r\n\r\n  // Add some padding on end of last diff.\r\n  patch = patches[patches.length - 1];\r\n  diffs = patch.diffs;\r\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\r\n    // Add nullPadding equality.\r\n    diffs.push([DIFF_EQUAL, nullPadding]);\r\n    patch.length1 += paddingLength;\r\n    patch.length2 += paddingLength;\r\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\r\n    // Grow last equality.\r\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\r\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\r\n    patch.length1 += extraLength;\r\n    patch.length2 += extraLength;\r\n  }\r\n\r\n  return nullPadding;\r\n};\r\n\r\n\r\n/**\r\n * Look through the patches and break up any which are longer than the maximum\r\n * limit of the match algorithm.\r\n * Intended to be called only from within patch_apply.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n */\r\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\r\n  var patch_size = this.Match_MaxBits;\r\n  for (var x = 0; x < patches.length; x++) {\r\n    if (patches[x].length1 <= patch_size) {\r\n      continue;\r\n    }\r\n    var bigpatch = patches[x];\r\n    // Remove the big old patch.\r\n    patches.splice(x--, 1);\r\n    var start1 = bigpatch.start1;\r\n    var start2 = bigpatch.start2;\r\n    var precontext = '';\r\n    while (bigpatch.diffs.length !== 0) {\r\n      // Create one of several smaller patches.\r\n      var patch = new diff_match_patch.patch_obj();\r\n      var empty = true;\r\n      patch.start1 = start1 - precontext.length;\r\n      patch.start2 = start2 - precontext.length;\r\n      if (precontext !== '') {\r\n        patch.length1 = patch.length2 = precontext.length;\r\n        patch.diffs.push([DIFF_EQUAL, precontext]);\r\n      }\r\n      while (bigpatch.diffs.length !== 0 &&\r\n             patch.length1 < patch_size - this.Patch_Margin) {\r\n        var diff_type = bigpatch.diffs[0][0];\r\n        var diff_text = bigpatch.diffs[0][1];\r\n        if (diff_type === DIFF_INSERT) {\r\n          // Insertions are harmless.\r\n          patch.length2 += diff_text.length;\r\n          start2 += diff_text.length;\r\n          patch.diffs.push(bigpatch.diffs.shift());\r\n          empty = false;\r\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\r\n                   patch.diffs[0][0] == DIFF_EQUAL &&\r\n                   diff_text.length > 2 * patch_size) {\r\n          // This is a large deletion.  Let it pass in one chunk.\r\n          patch.length1 += diff_text.length;\r\n          start1 += diff_text.length;\r\n          empty = false;\r\n          patch.diffs.push([diff_type, diff_text]);\r\n          bigpatch.diffs.shift();\r\n        } else {\r\n          // Deletion or equality.  Only take as much as we can stomach.\r\n          diff_text = diff_text.substring(0,\r\n              patch_size - patch.length1 - this.Patch_Margin);\r\n          patch.length1 += diff_text.length;\r\n          start1 += diff_text.length;\r\n          if (diff_type === DIFF_EQUAL) {\r\n            patch.length2 += diff_text.length;\r\n            start2 += diff_text.length;\r\n          } else {\r\n            empty = false;\r\n          }\r\n          patch.diffs.push([diff_type, diff_text]);\r\n          if (diff_text == bigpatch.diffs[0][1]) {\r\n            bigpatch.diffs.shift();\r\n          } else {\r\n            bigpatch.diffs[0][1] =\r\n                bigpatch.diffs[0][1].substring(diff_text.length);\r\n          }\r\n        }\r\n      }\r\n      // Compute the head context for the next patch.\r\n      precontext = this.diff_text2(patch.diffs);\r\n      precontext =\r\n          precontext.substring(precontext.length - this.Patch_Margin);\r\n      // Append the end context for this patch.\r\n      var postcontext = this.diff_text1(bigpatch.diffs)\r\n                            .substring(0, this.Patch_Margin);\r\n      if (postcontext !== '') {\r\n        patch.length1 += postcontext.length;\r\n        patch.length2 += postcontext.length;\r\n        if (patch.diffs.length !== 0 &&\r\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\r\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\r\n        } else {\r\n          patch.diffs.push([DIFF_EQUAL, postcontext]);\r\n        }\r\n      }\r\n      if (!empty) {\r\n        patches.splice(++x, 0, patch);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Take a list of patches and return a textual representation.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @return {string} Text representation of patches.\r\n */\r\ndiff_match_patch.prototype.patch_toText = function(patches) {\r\n  var text = [];\r\n  for (var x = 0; x < patches.length; x++) {\r\n    text[x] = patches[x];\r\n  }\r\n  return text.join('');\r\n};\r\n\r\n\r\n/**\r\n * Parse a textual representation of patches and return a list of Patch objects.\r\n * @param {string} textline Text representation of patches.\r\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n * @throws {!Error} If invalid input.\r\n */\r\ndiff_match_patch.prototype.patch_fromText = function(textline) {\r\n  var patches = [];\r\n  if (!textline) {\r\n    return patches;\r\n  }\r\n  var text = textline.split('\\n');\r\n  var textPointer = 0;\r\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\r\n  while (textPointer < text.length) {\r\n    var m = text[textPointer].match(patchHeader);\r\n    if (!m) {\r\n      throw new Error('Invalid patch string: ' + text[textPointer]);\r\n    }\r\n    var patch = new diff_match_patch.patch_obj();\r\n    patches.push(patch);\r\n    patch.start1 = parseInt(m[1], 10);\r\n    if (m[2] === '') {\r\n      patch.start1--;\r\n      patch.length1 = 1;\r\n    } else if (m[2] == '0') {\r\n      patch.length1 = 0;\r\n    } else {\r\n      patch.start1--;\r\n      patch.length1 = parseInt(m[2], 10);\r\n    }\r\n\r\n    patch.start2 = parseInt(m[3], 10);\r\n    if (m[4] === '') {\r\n      patch.start2--;\r\n      patch.length2 = 1;\r\n    } else if (m[4] == '0') {\r\n      patch.length2 = 0;\r\n    } else {\r\n      patch.start2--;\r\n      patch.length2 = parseInt(m[4], 10);\r\n    }\r\n    textPointer++;\r\n\r\n    while (textPointer < text.length) {\r\n      var sign = text[textPointer].charAt(0);\r\n      try {\r\n        var line = decodeURI(text[textPointer].substring(1));\r\n      } catch (ex) {\r\n        // Malformed URI sequence.\r\n        throw new Error('Illegal escape in patch_fromText: ' + line);\r\n      }\r\n      if (sign == '-') {\r\n        // Deletion.\r\n        patch.diffs.push([DIFF_DELETE, line]);\r\n      } else if (sign == '+') {\r\n        // Insertion.\r\n        patch.diffs.push([DIFF_INSERT, line]);\r\n      } else if (sign == ' ') {\r\n        // Minor equality.\r\n        patch.diffs.push([DIFF_EQUAL, line]);\r\n      } else if (sign == '@') {\r\n        // Start of next patch.\r\n        break;\r\n      } else if (sign === '') {\r\n        // Blank line?  Whatever.\r\n      } else {\r\n        // WTF?\r\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\r\n      }\r\n      textPointer++;\r\n    }\r\n  }\r\n  return patches;\r\n};\r\n\r\n\r\n/**\r\n * Class representing one patch operation.\r\n * @constructor\r\n */\r\ndiff_match_patch.patch_obj = function() {\r\n  /** @type {!Array.<!diff_match_patch.Diff>} */\r\n  this.diffs = [];\r\n  /** @type {?number} */\r\n  this.start1 = null;\r\n  /** @type {?number} */\r\n  this.start2 = null;\r\n  /** @type {number} */\r\n  this.length1 = 0;\r\n  /** @type {number} */\r\n  this.length2 = 0;\r\n};\r\n\r\n\r\n/**\r\n * Emmulate GNU diff's format.\r\n * Header: @@ -382,8 +481,9 @@\r\n * Indicies are printed as 1-based, not 0-based.\r\n * @return {string} The GNU diff string.\r\n */\r\ndiff_match_patch.patch_obj.prototype.toString = function() {\r\n  var coords1, coords2;\r\n  if (this.length1 === 0) {\r\n    coords1 = this.start1 + ',0';\r\n  } else if (this.length1 == 1) {\r\n    coords1 = this.start1 + 1;\r\n  } else {\r\n    coords1 = (this.start1 + 1) + ',' + this.length1;\r\n  }\r\n  if (this.length2 === 0) {\r\n    coords2 = this.start2 + ',0';\r\n  } else if (this.length2 == 1) {\r\n    coords2 = this.start2 + 1;\r\n  } else {\r\n    coords2 = (this.start2 + 1) + ',' + this.length2;\r\n  }\r\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\r\n  var op;\r\n  // Escape the body of the patch with %xx notation.\r\n  for (var x = 0; x < this.diffs.length; x++) {\r\n    switch (this.diffs[x][0]) {\r\n      case DIFF_INSERT:\r\n        op = '+';\r\n        break;\r\n      case DIFF_DELETE:\r\n        op = '-';\r\n        break;\r\n      case DIFF_EQUAL:\r\n        op = ' ';\r\n        break;\r\n    }\r\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\r\n  }\r\n  return text.join('').replace(/%20/g, ' ');\r\n};\r\n\r\n\r\n// The following export code was added by @ForbesLindesay\r\nmodule.exports = diff_match_patch;\r\nmodule.exports['diff_match_patch'] = diff_match_patch;\r\nmodule.exports['DIFF_DELETE'] = DIFF_DELETE;\r\nmodule.exports['DIFF_INSERT'] = DIFF_INSERT;\r\nmodule.exports['DIFF_EQUAL'] = DIFF_EQUAL;\r\n\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar enableArrayEquals = function enableArrayEquals() {\n  // Warn if overriding existing method\n  if (Array.prototype.equals) console.warn('Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there\\'s a framework conflict or you\\'ve got double inclusions in your code.');\n  // attach the .equals method to Array's prototype to call it on any array\n  Array.prototype.equals = function (array) {\n    // if the other array is a falsy value, return\n    if (!array) return false;\n\n    // compare lengths - can save a lot of time\n    if (this.length != array.length) return false;\n\n    for (var i = 0, l = this.length; i < l; i++) {\n      // Check if we have nested arrays\n      if (this[i] instanceof Array && array[i] instanceof Array) {\n        // recurse into the nested arrays\n        if (!this[i].equals(array[i])) return false;\n      } else if (this[i] != array[i]) {\n        // Warning - two different object instances will never be equal: {x:20} != {x:20}\n        return false;\n      }\n    }\n    return true;\n  };\n  // Hide method from for-in loops\n  Object.defineProperty(Array.prototype, 'equals', { enumerable: false });\n};\n\nexports.default = {\n  enableArrayEquals: enableArrayEquals\n};\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// js/index.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 22);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 43b23e97f1205b468482","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/isArray.js\n// module id = 0\n// module chunks = 0","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/isObject.js\n// module id = 1\n// module chunks = 0","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/identity.js\n// module id = 2\n// module chunks = 0","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseGetTag.js\n// module id = 3\n// module chunks = 0","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/isObjectLike.js\n// module id = 4\n// module chunks = 0","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/isArrayLike.js\n// module id = 5\n// module chunks = 0","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_Symbol.js\n// module id = 6\n// module chunks = 0","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_root.js\n// module id = 7\n// module chunks = 0","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_arrayPush.js\n// module id = 8\n// module chunks = 0","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_freeGlobal.js\n// module id = 9\n// module chunks = 0","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/isArguments.js\n// module id = 10\n// module chunks = 0","var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseAssignValue.js\n// module id = 11\n// module chunks = 0","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_defineProperty.js\n// module id = 12\n// module chunks = 0","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/isFunction.js\n// module id = 13\n// module chunks = 0","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/eq.js\n// module id = 14\n// module chunks = 0","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/isLength.js\n// module id = 15\n// module chunks = 0","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_isIndex.js\n// module id = 16\n// module chunks = 0","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_arrayLikeKeys.js\n// module id = 17\n// module chunks = 0","module.exports = function(module) {\n\tif(!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif(!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 18\n// module chunks = 0","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_isPrototype.js\n// module id = 19\n// module chunks = 0","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/isSymbol.js\n// module id = 20\n// module chunks = 0","var isSymbol = require('./isSymbol');\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined\n          ? (current === current && !isSymbol(current))\n          : comparator(current, computed)\n        )) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseExtremum;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseExtremum.js\n// module id = 21\n// module chunks = 0","/* See LICENSE file for terms of use */\n'use strict'\n\nimport concat from 'lodash/concat'\nimport extend from 'lodash/extend'\nimport forEach from 'lodash/forEach'\nimport indexOf from 'lodash/indexOf'\nimport isArray from 'lodash/isArray'\nimport max from 'lodash/max'\nimport min from 'lodash/min'\nimport diff_match_patch from 'diff-match-patch'\nimport util from './util'\n\nutil.enableArrayEquals()\n\nclass Content {\n  constructor(content){\n    this.diffMatchPatch = new diff_match_patch()\n    this.content = content\n    this.newContent = undefined\n    this.patches = []\n    this.loadPatches = this.loadPatches.bind(this)\n    this.applyPatch = this.applyPatch.bind(this)\n    this.setContent = this.setContent.bind(this)\n    this.getContent = this.getContent.bind(this)\n    this.threeWayMerge = this.threeWayMerge.bind(this)\n    this.updatePatches = this.updatePatches.bind(this)\n  }\n\n  loadPatches(patches){\n    this.patches = concat([], patches)\n  }\n\n  addPatch(patch){\n    this.patches.push([patch, true])\n  }\n\n  applyPatch(patch, isReturnContent) {\n    let content = this.content\n    const { patchObj, id, isApplied, isUpdated } = patch\n    if(isApplied){\n      throw new Error('The patch cannot be applied, because it was applied before')\n    }\n    if(!isUpdated){\n      throw new Error('The patch cannot be applied, because it has conflict')\n    }\n    if(id === undefined || id === null){\n      throw new Error('id cannot be undefined or null')\n    }\n    forEach(patchObj, ptc => {\n      const { diffs, start1, length1 } = ptc\n      let replacement = ''\n      forEach(diffs, diff => {\n        if(diff[0] !== -1){\n          replacement += diff[1]\n        }\n      })\n      content = content.substring(0, start1) + replacement + content.substring(start1 + length1, content.length)\n    })\n    if(isReturnContent){\n      return content\n    }else{\n      this.newContent = content\n      this.updatePatches(patch)\n    }\n  }\n\n  updatePatches(patch) {\n    let patches = concat([], this.patches)\n    const { patchObj, id } = patch\n    if(patchObj.length === 0){\n      throw new Error('patchObj cannot be empty')\n    }\n    const { content, newContent } = this\n    let updatedPatches = []\n    forEach(patches, ptc => {\n      const ptcId = ptc.id\n      if(ptcId === id){\n        ptc.isApplied = true\n        ptc.isUpdated = true\n        updatedPatches.push(ptc)\n      }else{\n        const ptcIsApplied = ptc.isApplied\n        const ptcIsUpdated = ptc.isUpdated\n        if(ptcIsApplied || !ptcIsUpdated){\n          updatedPatches.push(ptc)\n        }else{\n          const ptcObj = ptc.patchObj\n          const ptcOrgStart = ptcObj[0].start1\n          const ptcOrgEnd = ptcObj[ptcObj.length - 1].start1 + ptcObj[ptcObj.length - 1].length1\n          const patchOrgStart = patchObj[0].start1\n          const patchOrgEnd = patchObj[patchObj.length - 1].start1 + patchObj[patchObj.length - 1].length1\n          if(ptcOrgStart > patchOrgEnd) {\n            let lengthChange = 0\n            forEach(patchObj, obj => {\n              lengthChange += obj.length2 - obj.length1\n            })\n            forEach(ptcObj, (obj, index) => {\n              ptc.patchObj[index].start1 += lengthChange\n              ptc.patchObj[index].start2 += lengthChange\n            })\n            updatedPatches.push(ptc)\n          } else if (ptcOrgEnd < patchOrgStart) {\n            updatedPatches.push(ptc)\n          } else {\n            try {\n              const mergedResult = this.threeWayMerge(content, patchObj, ptcObj)\n              const mergedContent = mergedResult[0]\n              let startChange = 0\n              let endChange = 0\n              forEach(patchObj, obj => {\n                if(obj.start1 + obj.length1 <= ptcOrgStart + startChange){\n                  startChange += obj.length2 - obj.length1\n                  endChange += obj.length2 - obj.length1\n                }else if(obj.start1 <= ptcOrgStart + startChange){\n                  let diffLength = 0\n                  forEach(obj.diffs, diff => {\n                    const opt = diff[0]\n                    const chars = diff[1]\n                    if(obj.start1 + diffLength <= ptcOrgStart + startChange){\n                      startChange += opt * chars.length\n                      endChange += opt * chars.length\n                    }else{\n                      if(ptcOrgStart + startChange - obj.start1 - diffLength + chars.length >= 0){\n                        startChange += opt * (ptcOrgStart + startChange - obj.start1 - diffLength + chars.length)\n                      }\n                      if(obj.start1 + diffLength <= ptcOrgEnd + endChange){\n                        endChange += opt * chars.length\n                      } else if(obj.start1 + diffLength - chars.length <= ptcOrgEnd + endChange){\n                        endChange += opt * (ptcOrgEnd + endChange - obj.start1 - diffLength + chars.length)\n                      }\n                    }\n                    diffLength += chars.length\n                  })\n                }else if(obj.start1 > ptcOrgStart && obj.start1 + obj.length1 <= ptcOrgEnd){\n                  let diffLength\n                  forEach(obj.diffs, diff => {\n                    const opt = diff[0]\n                    const chars = diff[1]\n                    if(obj.start1 + diffLength <= ptcOrgEnd + endChange){\n                      endChange += opt * chars.length\n                    } else if(obj.start1 + diffLength - chars.length <= ptcOrgEnd + endChange){\n                      endChange += opt * (ptcOrgEnd + endChange - obj.start1 - diffLength + chars.length)\n                    }\n                    diffLength += chars.length\n                  })\n                }\n              })\n              const newStart = ptc.patchObj[0].start1 + startChange\n              const newEnd = ptc.patchObj[ptc.patchObj.length - 1].start1 + ptc.patchObj[ptc.patchObj.length - 1].length1 + endChange\n              let updatedPatchObj = this.diffMatchPatch.patch_make(newContent, mergedContent)\n              let tmpDiffs = []\n              let length2Change = 0\n              forEach(updatedPatchObj, (tmp, index) => {\n                if(tmp.start1 > newEnd || tmp.start1 + tmp.length1 < newStart){\n                  return\n                }\n                if (tmp.start1 <= newStart) {\n                  if(tmp.start1 + tmp.length1 < newStart){\n                    return\n                  } else {\n                    let tmpLength = 0\n                    forEach(tmp.diffs, diff => {\n                      let opt = diff[0]\n                      let chars = diff[1]\n                      if (opt === 0) {\n                        if (chars.length + tmp.start1 + tmpLength > newStart && chars.length + tmp.start1 + tmpLength <= newEnd) {\n                          tmpDiffs.push([opt, chars.substring(newStart - tmp.start1 - tmpLength, chars.length)])\n                        } else if (chars.length + tmp.start1 + tmpLength >= newStart && chars.length + tmp.start1 + tmpLength >= newEnd && tmp.start1 + tmpLength < newEnd) {\n                          tmpDiffs.push([opt, chars.substring(chars.length + tmp.start1 + tmpLength - newStart, newEnd - tmp.start1 - tmpLength)])\n                        }\n                        tmpLength += chars.length\n                      } else {\n                        if (tmp.start1 + tmpLength <= newEnd) {\n                          tmpDiffs.push(diff)\n                          length2Change += opt * chars.length\n                        }\n                      }\n                    })\n                  }\n                } else if(tmp.start1 >= newStart) {\n                  if(tmp.start1 > newEnd){\n                    return\n                  }\n                  if (tmp.start1 + tmp.length1 >= newEnd) {\n                    if(index === 0){\n                      tmpDiffs.push([0, newContent.substring(newStart, tmp.start1)])\n                      let tmpLength = 0\n                      forEach(tmp.diffs, diff => {\n                        let opt = diff[0]\n                        let chars = diff[1]\n                        if (opt === 0) {\n                          if (chars.length + tmp.start1 + tmpLength > newEnd) {\n                            tmpDiffs.push([opt, chars.substring(0, newEnd - tmp.start1 - tmpLength)])\n                          }\n                          tmpLength += chars.length\n                        } else {\n                          if (tmp.start1 + tmpLength < newEnd) {\n                            tmpDiffs.push(diff)\n                            length2Change += opt * chars.length\n                          }\n                        }\n                      })\n                    }else{\n                      let tmpLength = 0\n                      forEach(tmp.diffs, diff => {\n                        let opt = diff[0]\n                        let chars = diff[1]\n                        if (opt === 0) {\n                          if (chars.length + tmp.start1 + tmpLength > newEnd) {\n                            tmpDiffs.push([opt, chars.substring(0, newEnd - tmp.start1 - tmpLength)])\n                          } else {\n                            tmpDiffs.push(diff)\n                          }\n                          tmpLength += chars.length\n                        } else {\n                          if (tmp.start1 + tmpLength < newEnd) {\n                            tmpDiffs.push(diff)\n                            length2Change += opt * chars.length\n                          }\n                        }\n                      })\n                    }\n                  } else {\n                    if(index === 0){\n                      tmpDiffs.push([0, newContent.substring(newStart, tmp.start1)])\n                    }\n                    tmpDiffs = concat(tmpDiffs, tmp.diffs)\n                  }\n                }\n                if(index === updatedPatchObj.length - 1){\n                  if(tmp.start1 + tmp.length1 <= newEnd){\n                    tmpDiffs.push([0, newContent.substring(tmp.start1 + tmp.length1, newEnd)])\n                  }\n                }\n              })\n              let tmpPatchObj = [\n                {\n                  diffs: tmpDiffs,\n                  start1: newStart,\n                  start2: newStart,\n                  length1: newEnd - newStart,\n                  length2: newEnd - newStart + length2Change\n                }\n              ]\n              const updatedPatch = {\n                patchObj: tmpPatchObj,\n                id: ptcId,\n                isApplied: false,\n                isUpdated: true\n              }\n              updatedPatches.push(updatedPatch)\n            } catch(err) {\n              console.log(err)\n              ptc.isUpdated = false\n              updatedPatches.push(ptc)\n            }\n          }\n        }\n      }\n    })\n    this.patches = updatedPatches\n    this.setContent(newContent)\n    this.newContent = undefined\n  }\n\n  threeWayMerge(content, optB, optC) {\n    const contentLength = content.length\n    let optBCharsRange = []\n    let optCCharsRange = []\n    let optBChanges = 0\n    let optCChanges = 0\n    forEach(optB, patch => {\n      const { start1, length1, length2 } = patch\n      optBCharsRange.push(start1 - optBChanges)\n      if(start1 === 0){\n        optBCharsRange.push(start1 - optBChanges + length1 - 1)\n      }else{\n        optBCharsRange.push(start1 - optBChanges + length1)\n      }\n      optBChanges += length2 - length1\n    })\n    forEach(optC, patch => {\n      const { start1, length1, length2 } = patch\n      optCCharsRange.push(start1 - optCChanges)\n      if(start1 === 0){\n        optCCharsRange.push(start1 - optCChanges + length1 - 1)\n      }else{\n        optCCharsRange.push(start1 - optCChanges + length1)\n      }\n      optCChanges += length2 - length1\n    })\n\n    const start = min([min(optBCharsRange), min(optCCharsRange)])\n    const end = max([max(optBCharsRange), max(optCCharsRange)])\n    if(end >= contentLength) throw new Error('incorrect patch')\n    const editingContent = content.substring(start, end)\n    let contentDiff = this.genDiffLoop(0, editingContent)\n    let optBDiff = this.genOptDiff(optBCharsRange, optB, content, start, end)\n    let optCDiff = this.genOptDiff(optCCharsRange, optC, content, start, end)\n    let next = true\n    let i = 0\n    let newContent = []\n    let isPatchApplied = true\n    while(next){\n      const oneL = contentDiff[i]\n      const twoL = optBDiff[i]\n      const threeL = optCDiff[i]\n      let from\n      if(oneL || twoL || threeL){\n        let l\n        if(oneL && twoL && threeL){\n          if(oneL.equals(twoL)){\n            l = threeL\n            from = 'three'\n          } else if(oneL.equals(threeL)){\n            l = twoL\n            from = 'two'\n          } else if(twoL.equals(threeL)){\n            l = twoL\n            from = 'both'\n          }\n        } else if(twoL && !threeL){\n          l = twoL\n          from = 'two'\n        } else if(!twoL && threeL){\n          l = threeL\n          from = 'three'\n        }\n\n        if(l === undefined){\n          throw new Error('Conflict at position ', i)\n        } else {\n          const op = l[0]\n          if(op == 1){\n            const index = i == 0 ? 0 : i-1\n            if(from == 'two'){\n              contentDiff.splice(index, 0, l)\n              optCDiff.splice(index, 0, l)\n            } else if (from == 'three'){\n              contentDiff.splice(index, 0, l)\n              optBDiff.splice(index, 0, l)\n            } else {\n              contentDiff.splice(index, 0, l)\n            }\n          } else if(op == -1){\n            if(from == 'two'){\n              contentDiff.splice(i, 1, l)\n              optCDiff.splice(i, 1, l)\n            } else if (from == 'three'){\n              contentDiff.splice(i, 1, l)\n              optBDiff.splice(i, 1, l)\n            } else {\n              //  from == 'both'\n              contentDiff.splice(i, 1, l)\n            }\n          }\n          newContent.push(l)\n        }\n      }\n      next = next != false && (contentDiff[i + 1] || optBDiff[i + 1] || optCDiff[i + 1])\n      i++\n    }\n\n    const mergedPatch = this.diffMatchPatch.patch_make(newContent)\n    const mergedEditingContent = this.diffMatchPatch.patch_apply(mergedPatch, editingContent)\n    isPatchApplied = this.isPatchApplied(mergedEditingContent[1])\n    if(!isPatchApplied) throw new Error('Conflict happened')\n    const mergedContent = content.substring(0, start) + mergedEditingContent[0] + content.substring(end, contentLength)\n    return [mergedContent, isPatchApplied]\n  }\n\n  isPatchApplied(patchStatus) {\n    return indexOf(patchStatus, false) === -1\n  }\n\n  updateContent(content) {\n    this.content = content\n  }\n\n  getPatches() {\n    return concat([], this.patches)\n  }\n\n  getContent() {\n    return this.content\n  }\n\n  setContent(content) {\n    const type = typeof content\n    if(type === 'string'){\n      this.content = content\n      return\n    }\n    throw new TypeError(`String expected, but got ${type}`)\n  }\n\n  createPatch(changes) {\n    const type = typeof changes\n    if(type === 'object' && !isArray(changes)){\n      const { id, text1, text2 } = changes\n      const patchObj = this.diffMatchPatch.patch_make(text1, text2)\n      let patches = {\n        patchObj: patchObj,\n        id: id,\n        isUpdated: true,\n        isApplied: false\n      }\n      return patches\n    } else if (type === 'object') {\n      let patches = {\n        patchObj: [],\n        id: changes[0].id,\n        isUpdated: true,\n        isApplied: false\n      }\n      let lengthChange = 0\n      forEach(changes, (change, index) => {\n        const { start, orgChars, newChars } = change\n        let lengthUpdate = 0\n        const types = [typeof start, typeof orgChars, typeof newChars]\n        let errorMessage\n        if(types[0] !== 'number'){\n          errorMessage = `Number expected, but got ${types[0]}`\n        }\n        if(types[1] !== 'string'){\n          errorMessage = `String expected, but got ${types[1]}`\n        }\n        if(types[2] !== 'string'){\n          errorMessage = `String expected, but got ${types[2]}`\n        }\n        if(errorMessage){\n          throw new TypeError(errorMessage)\n        }\n        const diffs = this.diffMatchPatch.diff_main(orgChars, newChars)\n        forEach(diffs, diff => {\n          const opt = diff[0]\n          const length = diff[1].length\n          lengthUpdate += opt * length\n        })\n        const length1 = orgChars.length\n        const length2 = newChars.length\n        let patch = {}\n        if(index === 0){\n          patch = {\n            diffs: diffs,\n            start1: start,\n            start2: start,\n            length1: length1,\n            length2: length2\n          }\n        } else {\n          patch = {\n            diffs: diffs,\n            start1: start + lengthChange,\n            start2: start + lengthChange,\n            length1: length1,\n            length2: length2\n          }\n        }\n        patches.patchObj.push(patch)\n        lengthChange += lengthUpdate\n      })\n      return patches\n    }\n    throw new TypeError(`String expected, but got ${type}`)\n  }\n\n  genOptDiff(range, patches, content, start, end) {\n    let me = this\n    let optDiff = []\n    forEach(range, (position, index) => {\n      if(index % 2 !== 0){\n        const patch = patches[Math.floor(index/2)]\n        forEach(patch.diffs, diff => {\n          const action = diff[0]\n          const actionContent = diff[1]\n          let diffs = []\n          if(actionContent.length > 1){\n            diffs = me.genDiffLoop(action, actionContent)\n          }else{\n            diffs.push(diff)\n          }\n          optDiff = concat(optDiff, diffs)\n        })\n      }else{\n        const begin = index === 0 ? start : range[index - 1]\n        if(position > begin){\n          const equalContent = content.substring(begin, position)\n          const equalDiff = me.genDiffLoop(0, equalContent)\n          optDiff = concat(optDiff, equalDiff)\n        }\n      }\n      if(index === range.length - 1 && position !== end){\n        const equalContent = content.substring(position, end)\n        const equalDiff = me.genDiffLoop(0, equalContent)\n        optDiff = concat(optDiff, equalDiff)\n      }\n    })\n    return optDiff\n  }\n\n  genDiffLoop (action, content) {\n    let diffs = []\n    forEach(content, char => {\n      diffs.push([action, char])\n    })\n    return diffs\n  }\n\n  patchToText (patches) {\n    const { patchObj } = patches\n    const patchText = this.diffMatchPatch.patch_toText(patchObj)\n    const newPatch = extend({}, patches, { patchObj: patchText })\n    return JSON.stringify(newPatch)\n  }\n\n  patchFromText (text) {\n    const patch = JSON.parse(text)\n    const patchObj = this.diffMatchPatch.patch_fromText(patch.patchObj)\n    const newPatch = extend({}, patch, { patchObj: patchObj })\n    return newPatch\n  }\n}\n\nexport default Content\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","var arrayPush = require('./_arrayPush'),\n    baseFlatten = require('./_baseFlatten'),\n    copyArray = require('./_copyArray'),\n    isArray = require('./isArray');\n\n/**\n * Creates a new array concatenating `array` with any additional arrays\n * and/or values.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to concatenate.\n * @param {...*} [values] The values to concatenate.\n * @returns {Array} Returns the new concatenated array.\n * @example\n *\n * var array = [1];\n * var other = _.concat(array, 2, [3], [[4]]);\n *\n * console.log(other);\n * // => [1, 2, 3, [4]]\n *\n * console.log(array);\n * // => [1]\n */\nfunction concat() {\n  var length = arguments.length;\n  if (!length) {\n    return [];\n  }\n  var args = Array(length - 1),\n      array = arguments[0],\n      index = length;\n\n  while (index--) {\n    args[index - 1] = arguments[index];\n  }\n  return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n}\n\nmodule.exports = concat;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/concat.js\n// module id = 23\n// module chunks = 0","var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseFlatten.js\n// module id = 24\n// module chunks = 0","var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_isFlattenable.js\n// module id = 25\n// module chunks = 0","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\n} catch(e) {\n\t// This works if the window reference is available\n\tif(typeof window === \"object\")\n\t\tg = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 26\n// module chunks = 0","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseIsArguments.js\n// module id = 27\n// module chunks = 0","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_getRawTag.js\n// module id = 28\n// module chunks = 0","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_objectToString.js\n// module id = 29\n// module chunks = 0","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_copyArray.js\n// module id = 30\n// module chunks = 0","module.exports = require('./assignIn');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/extend.js\n// module id = 31\n// module chunks = 0","var copyObject = require('./_copyObject'),\n    createAssigner = require('./_createAssigner'),\n    keysIn = require('./keysIn');\n\n/**\n * This method is like `_.assign` except that it iterates over own and\n * inherited source properties.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @alias extend\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.assign\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * function Bar() {\n *   this.c = 3;\n * }\n *\n * Foo.prototype.b = 2;\n * Bar.prototype.d = 4;\n *\n * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n */\nvar assignIn = createAssigner(function(object, source) {\n  copyObject(source, keysIn(source), object);\n});\n\nmodule.exports = assignIn;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/assignIn.js\n// module id = 32\n// module chunks = 0","var assignValue = require('./_assignValue'),\n    baseAssignValue = require('./_baseAssignValue');\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_copyObject.js\n// module id = 33\n// module chunks = 0","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_assignValue.js\n// module id = 34\n// module chunks = 0","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_getNative.js\n// module id = 35\n// module chunks = 0","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseIsNative.js\n// module id = 36\n// module chunks = 0","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_isMasked.js\n// module id = 37\n// module chunks = 0","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_coreJsData.js\n// module id = 38\n// module chunks = 0","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_toSource.js\n// module id = 39\n// module chunks = 0","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_getValue.js\n// module id = 40\n// module chunks = 0","var baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_createAssigner.js\n// module id = 41\n// module chunks = 0","var identity = require('./identity'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseRest.js\n// module id = 42\n// module chunks = 0","var apply = require('./_apply');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_overRest.js\n// module id = 43\n// module chunks = 0","/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_apply.js\n// module id = 44\n// module chunks = 0","var baseSetToString = require('./_baseSetToString'),\n    shortOut = require('./_shortOut');\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_setToString.js\n// module id = 45\n// module chunks = 0","var constant = require('./constant'),\n    defineProperty = require('./_defineProperty'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseSetToString.js\n// module id = 46\n// module chunks = 0","/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/constant.js\n// module id = 47\n// module chunks = 0","/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_shortOut.js\n// module id = 48\n// module chunks = 0","var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_isIterateeCall.js\n// module id = 49\n// module chunks = 0","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeysIn = require('./_baseKeysIn'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/keysIn.js\n// module id = 50\n// module chunks = 0","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseTimes.js\n// module id = 51\n// module chunks = 0","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/isBuffer.js\n// module id = 52\n// module chunks = 0","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/stubFalse.js\n// module id = 53\n// module chunks = 0","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/isTypedArray.js\n// module id = 54\n// module chunks = 0","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseIsTypedArray.js\n// module id = 55\n// module chunks = 0","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseUnary.js\n// module id = 56\n// module chunks = 0","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_nodeUtil.js\n// module id = 57\n// module chunks = 0","var isObject = require('./isObject'),\n    isPrototype = require('./_isPrototype'),\n    nativeKeysIn = require('./_nativeKeysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseKeysIn.js\n// module id = 58\n// module chunks = 0","/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_nativeKeysIn.js\n// module id = 59\n// module chunks = 0","var arrayEach = require('./_arrayEach'),\n    baseEach = require('./_baseEach'),\n    castFunction = require('./_castFunction'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\nmodule.exports = forEach;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/forEach.js\n// module id = 60\n// module chunks = 0","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_arrayEach.js\n// module id = 61\n// module chunks = 0","var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseEach.js\n// module id = 62\n// module chunks = 0","var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseForOwn.js\n// module id = 63\n// module chunks = 0","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseFor.js\n// module id = 64\n// module chunks = 0","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_createBaseFor.js\n// module id = 65\n// module chunks = 0","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/keys.js\n// module id = 66\n// module chunks = 0","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseKeys.js\n// module id = 67\n// module chunks = 0","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_nativeKeys.js\n// module id = 68\n// module chunks = 0","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_overArg.js\n// module id = 69\n// module chunks = 0","var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_createBaseEach.js\n// module id = 70\n// module chunks = 0","var identity = require('./identity');\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\nmodule.exports = castFunction;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_castFunction.js\n// module id = 71\n// module chunks = 0","var baseIndexOf = require('./_baseIndexOf'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Gets the index at which the first occurrence of `value` is found in `array`\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. If `fromIndex` is negative, it's used as the\n * offset from the end of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n * @example\n *\n * _.indexOf([1, 2, 1, 2], 2);\n * // => 1\n *\n * // Search from the `fromIndex`.\n * _.indexOf([1, 2, 1, 2], 2, 2);\n * // => 3\n */\nfunction indexOf(array, value, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseIndexOf(array, value, index);\n}\n\nmodule.exports = indexOf;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/indexOf.js\n// module id = 72\n// module chunks = 0","var baseFindIndex = require('./_baseFindIndex'),\n    baseIsNaN = require('./_baseIsNaN'),\n    strictIndexOf = require('./_strictIndexOf');\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\nmodule.exports = baseIndexOf;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseIndexOf.js\n// module id = 73\n// module chunks = 0","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseFindIndex.js\n// module id = 74\n// module chunks = 0","/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\nmodule.exports = baseIsNaN;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseIsNaN.js\n// module id = 75\n// module chunks = 0","/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = strictIndexOf;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_strictIndexOf.js\n// module id = 76\n// module chunks = 0","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/toInteger.js\n// module id = 77\n// module chunks = 0","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/toFinite.js\n// module id = 78\n// module chunks = 0","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/toNumber.js\n// module id = 79\n// module chunks = 0","var baseExtremum = require('./_baseExtremum'),\n    baseGt = require('./_baseGt'),\n    identity = require('./identity');\n\n/**\n * Computes the maximum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the maximum value.\n * @example\n *\n * _.max([4, 2, 8, 6]);\n * // => 8\n *\n * _.max([]);\n * // => undefined\n */\nfunction max(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseGt)\n    : undefined;\n}\n\nmodule.exports = max;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/max.js\n// module id = 80\n// module chunks = 0","/**\n * The base implementation of `_.gt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is greater than `other`,\n *  else `false`.\n */\nfunction baseGt(value, other) {\n  return value > other;\n}\n\nmodule.exports = baseGt;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseGt.js\n// module id = 81\n// module chunks = 0","var baseExtremum = require('./_baseExtremum'),\n    baseLt = require('./_baseLt'),\n    identity = require('./identity');\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseLt)\n    : undefined;\n}\n\nmodule.exports = min;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/min.js\n// module id = 82\n// module chunks = 0","/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt(value, other) {\n  return value < other;\n}\n\nmodule.exports = baseLt;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lodash/_baseLt.js\n// module id = 83\n// module chunks = 0","'use strict'\r\n\r\n/**\r\n * Diff Match and Patch\r\n *\r\n * Copyright 2006 Google Inc.\r\n * http://code.google.com/p/google-diff-match-patch/\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @fileoverview Computes the difference between two texts to create a patch.\r\n * Applies the patch onto another text, allowing for errors.\r\n * @author fraser@google.com (Neil Fraser)\r\n */\r\n\r\n/**\r\n * Class containing the diff, match and patch methods.\r\n * @constructor\r\n */\r\nfunction diff_match_patch() {\r\n\r\n  // Defaults.\r\n  // Redefine these in your program to override the defaults.\r\n\r\n  // Number of seconds to map a diff before giving up (0 for infinity).\r\n  this.Diff_Timeout = 1.0;\r\n  // Cost of an empty edit operation in terms of edit characters.\r\n  this.Diff_EditCost = 4;\r\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\r\n  this.Match_Threshold = 0.5;\r\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\r\n  // A match this many characters away from the expected location will add\r\n  // 1.0 to the score (0.0 is a perfect match).\r\n  this.Match_Distance = 1000;\r\n  // When deleting a large block of text (over ~64 characters), how close do\r\n  // the contents have to be to match the expected contents. (0.0 = perfection,\r\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\r\n  // end points of a delete need to match.\r\n  this.Patch_DeleteThreshold = 0.5;\r\n  // Chunk size for context length.\r\n  this.Patch_Margin = 4;\r\n\r\n  // The number of bits in an int.\r\n  this.Match_MaxBits = 32;\r\n}\r\n\r\n\r\n//  DIFF FUNCTIONS\r\n\r\n\r\n/**\r\n * The data structure representing a diff is an array of tuples:\r\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\r\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\r\n */\r\nvar DIFF_DELETE = -1;\r\nvar DIFF_INSERT = 1;\r\nvar DIFF_EQUAL = 0;\r\n\r\n/** @typedef {{0: number, 1: string}} */\r\ndiff_match_patch.Diff;\r\n\r\n\r\n/**\r\n * Find the differences between two texts.  Simplifies the problem by stripping\r\n * any common prefix or suffix off the texts before diffing.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\r\n *     then don't run a line-level diff first to identify the changed areas.\r\n *     Defaults to true, which does a faster, slightly less optimal diff.\r\n * @param {number} opt_deadline Optional time when the diff should be complete\r\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\r\n *     instead.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\r\n    opt_deadline) {\r\n  // Set a deadline by which time the diff must be complete.\r\n  if (typeof opt_deadline == 'undefined') {\r\n    if (this.Diff_Timeout <= 0) {\r\n      opt_deadline = Number.MAX_VALUE;\r\n    } else {\r\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\r\n    }\r\n  }\r\n  var deadline = opt_deadline;\r\n\r\n  // Check for null inputs.\r\n  if (text1 == null || text2 == null) {\r\n    throw new Error('Null input. (diff_main)');\r\n  }\r\n\r\n  // Check for equality (speedup).\r\n  if (text1 == text2) {\r\n    if (text1) {\r\n      return [[DIFF_EQUAL, text1]];\r\n    }\r\n    return [];\r\n  }\r\n\r\n  if (typeof opt_checklines == 'undefined') {\r\n    opt_checklines = true;\r\n  }\r\n  var checklines = opt_checklines;\r\n\r\n  // Trim off common prefix (speedup).\r\n  var commonlength = this.diff_commonPrefix(text1, text2);\r\n  var commonprefix = text1.substring(0, commonlength);\r\n  text1 = text1.substring(commonlength);\r\n  text2 = text2.substring(commonlength);\r\n\r\n  // Trim off common suffix (speedup).\r\n  commonlength = this.diff_commonSuffix(text1, text2);\r\n  var commonsuffix = text1.substring(text1.length - commonlength);\r\n  text1 = text1.substring(0, text1.length - commonlength);\r\n  text2 = text2.substring(0, text2.length - commonlength);\r\n\r\n  // Compute the diff on the middle block.\r\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\r\n\r\n  // Restore the prefix and suffix.\r\n  if (commonprefix) {\r\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\r\n  }\r\n  if (commonsuffix) {\r\n    diffs.push([DIFF_EQUAL, commonsuffix]);\r\n  }\r\n  this.diff_cleanupMerge(diffs);\r\n  return diffs;\r\n};\r\n\r\n\r\n/**\r\n * Find the differences between two texts.  Assumes that the texts do not\r\n * have any common prefix or suffix.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\r\n *     line-level diff first to identify the changed areas.\r\n *     If true, then run a faster, slightly less optimal diff.\r\n * @param {number} deadline Time when the diff should be complete by.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\r\n    deadline) {\r\n  var diffs;\r\n\r\n  if (!text1) {\r\n    // Just add some text (speedup).\r\n    return [[DIFF_INSERT, text2]];\r\n  }\r\n\r\n  if (!text2) {\r\n    // Just delete some text (speedup).\r\n    return [[DIFF_DELETE, text1]];\r\n  }\r\n\r\n  var longtext = text1.length > text2.length ? text1 : text2;\r\n  var shorttext = text1.length > text2.length ? text2 : text1;\r\n  var i = longtext.indexOf(shorttext);\r\n  if (i != -1) {\r\n    // Shorter text is inside the longer text (speedup).\r\n    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\r\n             [DIFF_EQUAL, shorttext],\r\n             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\r\n    // Swap insertions for deletions if diff is reversed.\r\n    if (text1.length > text2.length) {\r\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\r\n    }\r\n    return diffs;\r\n  }\r\n\r\n  if (shorttext.length == 1) {\r\n    // Single character string.\r\n    // After the previous speedup, the character can't be an equality.\r\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\r\n  }\r\n\r\n  // Check to see if the problem can be split in two.\r\n  var hm = this.diff_halfMatch_(text1, text2);\r\n  if (hm) {\r\n    // A half-match was found, sort out the return data.\r\n    var text1_a = hm[0];\r\n    var text1_b = hm[1];\r\n    var text2_a = hm[2];\r\n    var text2_b = hm[3];\r\n    var mid_common = hm[4];\r\n    // Send both pairs off for separate processing.\r\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\r\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\r\n    // Merge the results.\r\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\r\n  }\r\n\r\n  if (checklines && text1.length > 100 && text2.length > 100) {\r\n    return this.diff_lineMode_(text1, text2, deadline);\r\n  }\r\n\r\n  return this.diff_bisect_(text1, text2, deadline);\r\n};\r\n\r\n\r\n/**\r\n * Do a quick line-level diff on both strings, then rediff the parts for\r\n * greater accuracy.\r\n * This speedup can produce non-minimal diffs.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {number} deadline Time when the diff should be complete by.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\r\n  // Scan the text on a line-by-line basis first.\r\n  var a = this.diff_linesToChars_(text1, text2);\r\n  text1 = a.chars1;\r\n  text2 = a.chars2;\r\n  var linearray = a.lineArray;\r\n\r\n  var diffs = this.diff_main(text1, text2, false, deadline);\r\n\r\n  // Convert the diff back to original text.\r\n  this.diff_charsToLines_(diffs, linearray);\r\n  // Eliminate freak matches (e.g. blank lines)\r\n  this.diff_cleanupSemantic(diffs);\r\n\r\n  // Rediff any replacement blocks, this time character-by-character.\r\n  // Add a dummy entry at the end.\r\n  diffs.push([DIFF_EQUAL, '']);\r\n  var pointer = 0;\r\n  var count_delete = 0;\r\n  var count_insert = 0;\r\n  var text_delete = '';\r\n  var text_insert = '';\r\n  while (pointer < diffs.length) {\r\n    switch (diffs[pointer][0]) {\r\n      case DIFF_INSERT:\r\n        count_insert++;\r\n        text_insert += diffs[pointer][1];\r\n        break;\r\n      case DIFF_DELETE:\r\n        count_delete++;\r\n        text_delete += diffs[pointer][1];\r\n        break;\r\n      case DIFF_EQUAL:\r\n        // Upon reaching an equality, check for prior redundancies.\r\n        if (count_delete >= 1 && count_insert >= 1) {\r\n          // Delete the offending records and add the merged ones.\r\n          diffs.splice(pointer - count_delete - count_insert,\r\n                       count_delete + count_insert);\r\n          pointer = pointer - count_delete - count_insert;\r\n          var a = this.diff_main(text_delete, text_insert, false, deadline);\r\n          for (var j = a.length - 1; j >= 0; j--) {\r\n            diffs.splice(pointer, 0, a[j]);\r\n          }\r\n          pointer = pointer + a.length;\r\n        }\r\n        count_insert = 0;\r\n        count_delete = 0;\r\n        text_delete = '';\r\n        text_insert = '';\r\n        break;\r\n    }\r\n    pointer++;\r\n  }\r\n  diffs.pop();  // Remove the dummy entry at the end.\r\n\r\n  return diffs;\r\n};\r\n\r\n\r\n/**\r\n * Find the 'middle snake' of a diff, split the problem in two\r\n * and return the recursively constructed diff.\r\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {number} deadline Time at which to bail if not yet complete.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\r\n  // Cache the text lengths to prevent multiple calls.\r\n  var text1_length = text1.length;\r\n  var text2_length = text2.length;\r\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\r\n  var v_offset = max_d;\r\n  var v_length = 2 * max_d;\r\n  var v1 = new Array(v_length);\r\n  var v2 = new Array(v_length);\r\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\r\n  // integers and undefined.\r\n  for (var x = 0; x < v_length; x++) {\r\n    v1[x] = -1;\r\n    v2[x] = -1;\r\n  }\r\n  v1[v_offset + 1] = 0;\r\n  v2[v_offset + 1] = 0;\r\n  var delta = text1_length - text2_length;\r\n  // If the total number of characters is odd, then the front path will collide\r\n  // with the reverse path.\r\n  var front = (delta % 2 != 0);\r\n  // Offsets for start and end of k loop.\r\n  // Prevents mapping of space beyond the grid.\r\n  var k1start = 0;\r\n  var k1end = 0;\r\n  var k2start = 0;\r\n  var k2end = 0;\r\n  for (var d = 0; d < max_d; d++) {\r\n    // Bail out if deadline is reached.\r\n    if ((new Date()).getTime() > deadline) {\r\n      break;\r\n    }\r\n\r\n    // Walk the front path one step.\r\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\r\n      var k1_offset = v_offset + k1;\r\n      var x1;\r\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\r\n        x1 = v1[k1_offset + 1];\r\n      } else {\r\n        x1 = v1[k1_offset - 1] + 1;\r\n      }\r\n      var y1 = x1 - k1;\r\n      while (x1 < text1_length && y1 < text2_length &&\r\n             text1.charAt(x1) == text2.charAt(y1)) {\r\n        x1++;\r\n        y1++;\r\n      }\r\n      v1[k1_offset] = x1;\r\n      if (x1 > text1_length) {\r\n        // Ran off the right of the graph.\r\n        k1end += 2;\r\n      } else if (y1 > text2_length) {\r\n        // Ran off the bottom of the graph.\r\n        k1start += 2;\r\n      } else if (front) {\r\n        var k2_offset = v_offset + delta - k1;\r\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\r\n          // Mirror x2 onto top-left coordinate system.\r\n          var x2 = text1_length - v2[k2_offset];\r\n          if (x1 >= x2) {\r\n            // Overlap detected.\r\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Walk the reverse path one step.\r\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\r\n      var k2_offset = v_offset + k2;\r\n      var x2;\r\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\r\n        x2 = v2[k2_offset + 1];\r\n      } else {\r\n        x2 = v2[k2_offset - 1] + 1;\r\n      }\r\n      var y2 = x2 - k2;\r\n      while (x2 < text1_length && y2 < text2_length &&\r\n             text1.charAt(text1_length - x2 - 1) ==\r\n             text2.charAt(text2_length - y2 - 1)) {\r\n        x2++;\r\n        y2++;\r\n      }\r\n      v2[k2_offset] = x2;\r\n      if (x2 > text1_length) {\r\n        // Ran off the left of the graph.\r\n        k2end += 2;\r\n      } else if (y2 > text2_length) {\r\n        // Ran off the top of the graph.\r\n        k2start += 2;\r\n      } else if (!front) {\r\n        var k1_offset = v_offset + delta - k2;\r\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\r\n          var x1 = v1[k1_offset];\r\n          var y1 = v_offset + x1 - k1_offset;\r\n          // Mirror x2 onto top-left coordinate system.\r\n          x2 = text1_length - x2;\r\n          if (x1 >= x2) {\r\n            // Overlap detected.\r\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Diff took too long and hit the deadline or\r\n  // number of diffs equals number of characters, no commonality at all.\r\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\r\n};\r\n\r\n\r\n/**\r\n * Given the location of the 'middle snake', split the diff in two parts\r\n * and recurse.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {number} x Index of split point in text1.\r\n * @param {number} y Index of split point in text2.\r\n * @param {number} deadline Time at which to bail if not yet complete.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\r\n    deadline) {\r\n  var text1a = text1.substring(0, x);\r\n  var text2a = text2.substring(0, y);\r\n  var text1b = text1.substring(x);\r\n  var text2b = text2.substring(y);\r\n\r\n  // Compute both diffs serially.\r\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\r\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\r\n\r\n  return diffs.concat(diffsb);\r\n};\r\n\r\n\r\n/**\r\n * Split two texts into an array of strings.  Reduce the texts to a string of\r\n * hashes where each Unicode character represents one line.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\r\n *     An object containing the encoded text1, the encoded text2 and\r\n *     the array of unique strings.\r\n *     The zeroth element of the array of unique strings is intentionally blank.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\r\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\r\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\r\n\r\n  // '\\x00' is a valid character, but various debuggers don't like it.\r\n  // So we'll insert a junk entry to avoid generating a null character.\r\n  lineArray[0] = '';\r\n\r\n  /**\r\n   * Split a text into an array of strings.  Reduce the texts to a string of\r\n   * hashes where each Unicode character represents one line.\r\n   * Modifies linearray and linehash through being a closure.\r\n   * @param {string} text String to encode.\r\n   * @return {string} Encoded string.\r\n   * @private\r\n   */\r\n  function diff_linesToCharsMunge_(text) {\r\n    var chars = '';\r\n    // Walk the text, pulling out a substring for each line.\r\n    // text.split('\\n') would would temporarily double our memory footprint.\r\n    // Modifying text would create many large strings to garbage collect.\r\n    var lineStart = 0;\r\n    var lineEnd = -1;\r\n    // Keeping our own length variable is faster than looking it up.\r\n    var lineArrayLength = lineArray.length;\r\n    while (lineEnd < text.length - 1) {\r\n      lineEnd = text.indexOf('\\n', lineStart);\r\n      if (lineEnd == -1) {\r\n        lineEnd = text.length - 1;\r\n      }\r\n      var line = text.substring(lineStart, lineEnd + 1);\r\n      lineStart = lineEnd + 1;\r\n\r\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\r\n          (lineHash[line] !== undefined)) {\r\n        chars += String.fromCharCode(lineHash[line]);\r\n      } else {\r\n        chars += String.fromCharCode(lineArrayLength);\r\n        lineHash[line] = lineArrayLength;\r\n        lineArray[lineArrayLength++] = line;\r\n      }\r\n    }\r\n    return chars;\r\n  }\r\n\r\n  var chars1 = diff_linesToCharsMunge_(text1);\r\n  var chars2 = diff_linesToCharsMunge_(text2);\r\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\r\n};\r\n\r\n\r\n/**\r\n * Rehydrate the text in a diff from a string of line hashes to real lines of\r\n * text.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @param {!Array.<string>} lineArray Array of unique strings.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var chars = diffs[x][1];\r\n    var text = [];\r\n    for (var y = 0; y < chars.length; y++) {\r\n      text[y] = lineArray[chars.charCodeAt(y)];\r\n    }\r\n    diffs[x][1] = text.join('');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Determine the common prefix of two strings.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {number} The number of characters common to the start of each\r\n *     string.\r\n */\r\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\r\n  // Quick check for common null cases.\r\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\r\n    return 0;\r\n  }\r\n  // Binary search.\r\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\r\n  var pointermin = 0;\r\n  var pointermax = Math.min(text1.length, text2.length);\r\n  var pointermid = pointermax;\r\n  var pointerstart = 0;\r\n  while (pointermin < pointermid) {\r\n    if (text1.substring(pointerstart, pointermid) ==\r\n        text2.substring(pointerstart, pointermid)) {\r\n      pointermin = pointermid;\r\n      pointerstart = pointermin;\r\n    } else {\r\n      pointermax = pointermid;\r\n    }\r\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\r\n  }\r\n  return pointermid;\r\n};\r\n\r\n\r\n/**\r\n * Determine the common suffix of two strings.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {number} The number of characters common to the end of each string.\r\n */\r\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\r\n  // Quick check for common null cases.\r\n  if (!text1 || !text2 ||\r\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\r\n    return 0;\r\n  }\r\n  // Binary search.\r\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\r\n  var pointermin = 0;\r\n  var pointermax = Math.min(text1.length, text2.length);\r\n  var pointermid = pointermax;\r\n  var pointerend = 0;\r\n  while (pointermin < pointermid) {\r\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\r\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\r\n      pointermin = pointermid;\r\n      pointerend = pointermin;\r\n    } else {\r\n      pointermax = pointermid;\r\n    }\r\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\r\n  }\r\n  return pointermid;\r\n};\r\n\r\n\r\n/**\r\n * Determine if the suffix of one string is the prefix of another.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {number} The number of characters common to the end of the first\r\n *     string and the start of the second string.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\r\n  // Cache the text lengths to prevent multiple calls.\r\n  var text1_length = text1.length;\r\n  var text2_length = text2.length;\r\n  // Eliminate the null case.\r\n  if (text1_length == 0 || text2_length == 0) {\r\n    return 0;\r\n  }\r\n  // Truncate the longer string.\r\n  if (text1_length > text2_length) {\r\n    text1 = text1.substring(text1_length - text2_length);\r\n  } else if (text1_length < text2_length) {\r\n    text2 = text2.substring(0, text1_length);\r\n  }\r\n  var text_length = Math.min(text1_length, text2_length);\r\n  // Quick check for the worst case.\r\n  if (text1 == text2) {\r\n    return text_length;\r\n  }\r\n\r\n  // Start by looking for a single character match\r\n  // and increase length until no match is found.\r\n  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\r\n  var best = 0;\r\n  var length = 1;\r\n  while (true) {\r\n    var pattern = text1.substring(text_length - length);\r\n    var found = text2.indexOf(pattern);\r\n    if (found == -1) {\r\n      return best;\r\n    }\r\n    length += found;\r\n    if (found == 0 || text1.substring(text_length - length) ==\r\n        text2.substring(0, length)) {\r\n      best = length;\r\n      length++;\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Do the two texts share a substring which is at least half the length of the\r\n * longer text?\r\n * This speedup can produce non-minimal diffs.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {Array.<string>} Five element Array, containing the prefix of\r\n *     text1, the suffix of text1, the prefix of text2, the suffix of\r\n *     text2 and the common middle.  Or null if there was no match.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\r\n  if (this.Diff_Timeout <= 0) {\r\n    // Don't risk returning a non-optimal diff if we have unlimited time.\r\n    return null;\r\n  }\r\n  var longtext = text1.length > text2.length ? text1 : text2;\r\n  var shorttext = text1.length > text2.length ? text2 : text1;\r\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\r\n    return null;  // Pointless.\r\n  }\r\n  var dmp = this;  // 'this' becomes 'window' in a closure.\r\n\r\n  /**\r\n   * Does a substring of shorttext exist within longtext such that the substring\r\n   * is at least half the length of longtext?\r\n   * Closure, but does not reference any external variables.\r\n   * @param {string} longtext Longer string.\r\n   * @param {string} shorttext Shorter string.\r\n   * @param {number} i Start index of quarter length substring within longtext.\r\n   * @return {Array.<string>} Five element Array, containing the prefix of\r\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\r\n   *     of shorttext and the common middle.  Or null if there was no match.\r\n   * @private\r\n   */\r\n  function diff_halfMatchI_(longtext, shorttext, i) {\r\n    // Start with a 1/4 length substring at position i as a seed.\r\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\r\n    var j = -1;\r\n    var best_common = '';\r\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\r\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\r\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\r\n                                               shorttext.substring(j));\r\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\r\n                                               shorttext.substring(0, j));\r\n      if (best_common.length < suffixLength + prefixLength) {\r\n        best_common = shorttext.substring(j - suffixLength, j) +\r\n            shorttext.substring(j, j + prefixLength);\r\n        best_longtext_a = longtext.substring(0, i - suffixLength);\r\n        best_longtext_b = longtext.substring(i + prefixLength);\r\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\r\n        best_shorttext_b = shorttext.substring(j + prefixLength);\r\n      }\r\n    }\r\n    if (best_common.length * 2 >= longtext.length) {\r\n      return [best_longtext_a, best_longtext_b,\r\n              best_shorttext_a, best_shorttext_b, best_common];\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // First check if the second quarter is the seed for a half-match.\r\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\r\n                             Math.ceil(longtext.length / 4));\r\n  // Check again based on the third quarter.\r\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\r\n                             Math.ceil(longtext.length / 2));\r\n  var hm;\r\n  if (!hm1 && !hm2) {\r\n    return null;\r\n  } else if (!hm2) {\r\n    hm = hm1;\r\n  } else if (!hm1) {\r\n    hm = hm2;\r\n  } else {\r\n    // Both matched.  Select the longest.\r\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\r\n  }\r\n\r\n  // A half-match was found, sort out the return data.\r\n  var text1_a, text1_b, text2_a, text2_b;\r\n  if (text1.length > text2.length) {\r\n    text1_a = hm[0];\r\n    text1_b = hm[1];\r\n    text2_a = hm[2];\r\n    text2_b = hm[3];\r\n  } else {\r\n    text2_a = hm[0];\r\n    text2_b = hm[1];\r\n    text1_a = hm[2];\r\n    text1_b = hm[3];\r\n  }\r\n  var mid_common = hm[4];\r\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\r\n};\r\n\r\n\r\n/**\r\n * Reduce the number of edits by eliminating semantically trivial equalities.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\r\n  var changes = false;\r\n  var equalities = [];  // Stack of indices where equalities are found.\r\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\r\n  /** @type {?string} */\r\n  var lastequality = null;\r\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n  var pointer = 0;  // Index of current position.\r\n  // Number of characters that changed prior to the equality.\r\n  var length_insertions1 = 0;\r\n  var length_deletions1 = 0;\r\n  // Number of characters that changed after the equality.\r\n  var length_insertions2 = 0;\r\n  var length_deletions2 = 0;\r\n  while (pointer < diffs.length) {\r\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\r\n      equalities[equalitiesLength++] = pointer;\r\n      length_insertions1 = length_insertions2;\r\n      length_deletions1 = length_deletions2;\r\n      length_insertions2 = 0;\r\n      length_deletions2 = 0;\r\n      lastequality = diffs[pointer][1];\r\n    } else {  // An insertion or deletion.\r\n      if (diffs[pointer][0] == DIFF_INSERT) {\r\n        length_insertions2 += diffs[pointer][1].length;\r\n      } else {\r\n        length_deletions2 += diffs[pointer][1].length;\r\n      }\r\n      // Eliminate an equality that is smaller or equal to the edits on both\r\n      // sides of it.\r\n      if (lastequality && (lastequality.length <=\r\n          Math.max(length_insertions1, length_deletions1)) &&\r\n          (lastequality.length <= Math.max(length_insertions2,\r\n                                           length_deletions2))) {\r\n        // Duplicate record.\r\n        diffs.splice(equalities[equalitiesLength - 1], 0,\r\n                     [DIFF_DELETE, lastequality]);\r\n        // Change second copy to insert.\r\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\r\n        // Throw away the equality we just deleted.\r\n        equalitiesLength--;\r\n        // Throw away the previous equality (it needs to be reevaluated).\r\n        equalitiesLength--;\r\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\r\n        length_insertions1 = 0;  // Reset the counters.\r\n        length_deletions1 = 0;\r\n        length_insertions2 = 0;\r\n        length_deletions2 = 0;\r\n        lastequality = null;\r\n        changes = true;\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n\r\n  // Normalize the diff.\r\n  if (changes) {\r\n    this.diff_cleanupMerge(diffs);\r\n  }\r\n  this.diff_cleanupSemanticLossless(diffs);\r\n\r\n  // Find any overlaps between deletions and insertions.\r\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\r\n  //   -> <del>abc</del>xxx<ins>def</ins>\r\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\r\n  //   -> <ins>def</ins>xxx<del>abc</del>\r\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\r\n  pointer = 1;\r\n  while (pointer < diffs.length) {\r\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\r\n        diffs[pointer][0] == DIFF_INSERT) {\r\n      var deletion = diffs[pointer - 1][1];\r\n      var insertion = diffs[pointer][1];\r\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\r\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\r\n      if (overlap_length1 >= overlap_length2) {\r\n        if (overlap_length1 >= deletion.length / 2 ||\r\n            overlap_length1 >= insertion.length / 2) {\r\n          // Overlap found.  Insert an equality and trim the surrounding edits.\r\n          diffs.splice(pointer, 0,\r\n              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);\r\n          diffs[pointer - 1][1] =\r\n              deletion.substring(0, deletion.length - overlap_length1);\r\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\r\n          pointer++;\r\n        }\r\n      } else {\r\n        if (overlap_length2 >= deletion.length / 2 ||\r\n            overlap_length2 >= insertion.length / 2) {\r\n          // Reverse overlap found.\r\n          // Insert an equality and swap and trim the surrounding edits.\r\n          diffs.splice(pointer, 0,\r\n              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);\r\n          diffs[pointer - 1][0] = DIFF_INSERT;\r\n          diffs[pointer - 1][1] =\r\n              insertion.substring(0, insertion.length - overlap_length2);\r\n          diffs[pointer + 1][0] = DIFF_DELETE;\r\n          diffs[pointer + 1][1] =\r\n              deletion.substring(overlap_length2);\r\n          pointer++;\r\n        }\r\n      }\r\n      pointer++;\r\n    }\r\n    pointer++;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Look for single edits surrounded on both sides by equalities\r\n * which can be shifted sideways to align the edit to a word boundary.\r\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\r\n  /**\r\n   * Given two strings, compute a score representing whether the internal\r\n   * boundary falls on logical boundaries.\r\n   * Scores range from 6 (best) to 0 (worst).\r\n   * Closure, but does not reference any external variables.\r\n   * @param {string} one First string.\r\n   * @param {string} two Second string.\r\n   * @return {number} The score.\r\n   * @private\r\n   */\r\n  function diff_cleanupSemanticScore_(one, two) {\r\n    if (!one || !two) {\r\n      // Edges are the best.\r\n      return 6;\r\n    }\r\n\r\n    // Each port of this function behaves slightly differently due to\r\n    // subtle differences in each language's definition of things like\r\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\r\n    // the choice has been made to use each language's native features\r\n    // rather than force total conformity.\r\n    var char1 = one.charAt(one.length - 1);\r\n    var char2 = two.charAt(0);\r\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\r\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\r\n    var whitespace1 = nonAlphaNumeric1 &&\r\n        char1.match(diff_match_patch.whitespaceRegex_);\r\n    var whitespace2 = nonAlphaNumeric2 &&\r\n        char2.match(diff_match_patch.whitespaceRegex_);\r\n    var lineBreak1 = whitespace1 &&\r\n        char1.match(diff_match_patch.linebreakRegex_);\r\n    var lineBreak2 = whitespace2 &&\r\n        char2.match(diff_match_patch.linebreakRegex_);\r\n    var blankLine1 = lineBreak1 &&\r\n        one.match(diff_match_patch.blanklineEndRegex_);\r\n    var blankLine2 = lineBreak2 &&\r\n        two.match(diff_match_patch.blanklineStartRegex_);\r\n\r\n    if (blankLine1 || blankLine2) {\r\n      // Five points for blank lines.\r\n      return 5;\r\n    } else if (lineBreak1 || lineBreak2) {\r\n      // Four points for line breaks.\r\n      return 4;\r\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\r\n      // Three points for end of sentences.\r\n      return 3;\r\n    } else if (whitespace1 || whitespace2) {\r\n      // Two points for whitespace.\r\n      return 2;\r\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\r\n      // One point for non-alphanumeric.\r\n      return 1;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  var pointer = 1;\r\n  // Intentionally ignore the first and last element (don't need checking).\r\n  while (pointer < diffs.length - 1) {\r\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\r\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\r\n      // This is a single edit surrounded by equalities.\r\n      var equality1 = diffs[pointer - 1][1];\r\n      var edit = diffs[pointer][1];\r\n      var equality2 = diffs[pointer + 1][1];\r\n\r\n      // First, shift the edit as far left as possible.\r\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\r\n      if (commonOffset) {\r\n        var commonString = edit.substring(edit.length - commonOffset);\r\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\r\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\r\n        equality2 = commonString + equality2;\r\n      }\r\n\r\n      // Second, step character by character right, looking for the best fit.\r\n      var bestEquality1 = equality1;\r\n      var bestEdit = edit;\r\n      var bestEquality2 = equality2;\r\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\r\n          diff_cleanupSemanticScore_(edit, equality2);\r\n      while (edit.charAt(0) === equality2.charAt(0)) {\r\n        equality1 += edit.charAt(0);\r\n        edit = edit.substring(1) + equality2.charAt(0);\r\n        equality2 = equality2.substring(1);\r\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\r\n            diff_cleanupSemanticScore_(edit, equality2);\r\n        // The >= encourages trailing rather than leading whitespace on edits.\r\n        if (score >= bestScore) {\r\n          bestScore = score;\r\n          bestEquality1 = equality1;\r\n          bestEdit = edit;\r\n          bestEquality2 = equality2;\r\n        }\r\n      }\r\n\r\n      if (diffs[pointer - 1][1] != bestEquality1) {\r\n        // We have an improvement, save it back to the diff.\r\n        if (bestEquality1) {\r\n          diffs[pointer - 1][1] = bestEquality1;\r\n        } else {\r\n          diffs.splice(pointer - 1, 1);\r\n          pointer--;\r\n        }\r\n        diffs[pointer][1] = bestEdit;\r\n        if (bestEquality2) {\r\n          diffs[pointer + 1][1] = bestEquality2;\r\n        } else {\r\n          diffs.splice(pointer + 1, 1);\r\n          pointer--;\r\n        }\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n};\r\n\r\n// Define some regex patterns for matching boundaries.\r\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\r\ndiff_match_patch.whitespaceRegex_ = /\\s/;\r\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\r\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\r\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\r\n\r\n/**\r\n * Reduce the number of edits by eliminating operationally trivial equalities.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\r\n  var changes = false;\r\n  var equalities = [];  // Stack of indices where equalities are found.\r\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\r\n  /** @type {?string} */\r\n  var lastequality = null;\r\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n  var pointer = 0;  // Index of current position.\r\n  // Is there an insertion operation before the last equality.\r\n  var pre_ins = false;\r\n  // Is there a deletion operation before the last equality.\r\n  var pre_del = false;\r\n  // Is there an insertion operation after the last equality.\r\n  var post_ins = false;\r\n  // Is there a deletion operation after the last equality.\r\n  var post_del = false;\r\n  while (pointer < diffs.length) {\r\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\r\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\r\n          (post_ins || post_del)) {\r\n        // Candidate found.\r\n        equalities[equalitiesLength++] = pointer;\r\n        pre_ins = post_ins;\r\n        pre_del = post_del;\r\n        lastequality = diffs[pointer][1];\r\n      } else {\r\n        // Not a candidate, and can never become one.\r\n        equalitiesLength = 0;\r\n        lastequality = null;\r\n      }\r\n      post_ins = post_del = false;\r\n    } else {  // An insertion or deletion.\r\n      if (diffs[pointer][0] == DIFF_DELETE) {\r\n        post_del = true;\r\n      } else {\r\n        post_ins = true;\r\n      }\r\n      /*\r\n       * Five types to be split:\r\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\r\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\r\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\r\n       * <ins>A</del>X<ins>C</ins><del>D</del>\r\n       * <ins>A</ins><del>B</del>X<del>C</del>\r\n       */\r\n      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\r\n                           ((lastequality.length < this.Diff_EditCost / 2) &&\r\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\r\n        // Duplicate record.\r\n        diffs.splice(equalities[equalitiesLength - 1], 0,\r\n                     [DIFF_DELETE, lastequality]);\r\n        // Change second copy to insert.\r\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\r\n        equalitiesLength--;  // Throw away the equality we just deleted;\r\n        lastequality = null;\r\n        if (pre_ins && pre_del) {\r\n          // No changes made which could affect previous entry, keep going.\r\n          post_ins = post_del = true;\r\n          equalitiesLength = 0;\r\n        } else {\r\n          equalitiesLength--;  // Throw away the previous equality.\r\n          pointer = equalitiesLength > 0 ?\r\n              equalities[equalitiesLength - 1] : -1;\r\n          post_ins = post_del = false;\r\n        }\r\n        changes = true;\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n\r\n  if (changes) {\r\n    this.diff_cleanupMerge(diffs);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Reorder and merge like edit sections.  Merge equalities.\r\n * Any edit section can move as long as it doesn't cross an equality.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\r\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\r\n  var pointer = 0;\r\n  var count_delete = 0;\r\n  var count_insert = 0;\r\n  var text_delete = '';\r\n  var text_insert = '';\r\n  var commonlength;\r\n  while (pointer < diffs.length) {\r\n    switch (diffs[pointer][0]) {\r\n      case DIFF_INSERT:\r\n        count_insert++;\r\n        text_insert += diffs[pointer][1];\r\n        pointer++;\r\n        break;\r\n      case DIFF_DELETE:\r\n        count_delete++;\r\n        text_delete += diffs[pointer][1];\r\n        pointer++;\r\n        break;\r\n      case DIFF_EQUAL:\r\n        // Upon reaching an equality, check for prior redundancies.\r\n        if (count_delete + count_insert > 1) {\r\n          if (count_delete !== 0 && count_insert !== 0) {\r\n            // Factor out any common prefixies.\r\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\r\n            if (commonlength !== 0) {\r\n              if ((pointer - count_delete - count_insert) > 0 &&\r\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\r\n                  DIFF_EQUAL) {\r\n                diffs[pointer - count_delete - count_insert - 1][1] +=\r\n                    text_insert.substring(0, commonlength);\r\n              } else {\r\n                diffs.splice(0, 0, [DIFF_EQUAL,\r\n                                    text_insert.substring(0, commonlength)]);\r\n                pointer++;\r\n              }\r\n              text_insert = text_insert.substring(commonlength);\r\n              text_delete = text_delete.substring(commonlength);\r\n            }\r\n            // Factor out any common suffixies.\r\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\r\n            if (commonlength !== 0) {\r\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\r\n                  commonlength) + diffs[pointer][1];\r\n              text_insert = text_insert.substring(0, text_insert.length -\r\n                  commonlength);\r\n              text_delete = text_delete.substring(0, text_delete.length -\r\n                  commonlength);\r\n            }\r\n          }\r\n          // Delete the offending records and add the merged ones.\r\n          if (count_delete === 0) {\r\n            diffs.splice(pointer - count_insert,\r\n                count_delete + count_insert, [DIFF_INSERT, text_insert]);\r\n          } else if (count_insert === 0) {\r\n            diffs.splice(pointer - count_delete,\r\n                count_delete + count_insert, [DIFF_DELETE, text_delete]);\r\n          } else {\r\n            diffs.splice(pointer - count_delete - count_insert,\r\n                count_delete + count_insert, [DIFF_DELETE, text_delete],\r\n                [DIFF_INSERT, text_insert]);\r\n          }\r\n          pointer = pointer - count_delete - count_insert +\r\n                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\r\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\r\n          // Merge this equality with the previous one.\r\n          diffs[pointer - 1][1] += diffs[pointer][1];\r\n          diffs.splice(pointer, 1);\r\n        } else {\r\n          pointer++;\r\n        }\r\n        count_insert = 0;\r\n        count_delete = 0;\r\n        text_delete = '';\r\n        text_insert = '';\r\n        break;\r\n    }\r\n  }\r\n  if (diffs[diffs.length - 1][1] === '') {\r\n    diffs.pop();  // Remove the dummy entry at the end.\r\n  }\r\n\r\n  // Second pass: look for single edits surrounded on both sides by equalities\r\n  // which can be shifted sideways to eliminate an equality.\r\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\r\n  var changes = false;\r\n  pointer = 1;\r\n  // Intentionally ignore the first and last element (don't need checking).\r\n  while (pointer < diffs.length - 1) {\r\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\r\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\r\n      // This is a single edit surrounded by equalities.\r\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\r\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\r\n        // Shift the edit over the previous equality.\r\n        diffs[pointer][1] = diffs[pointer - 1][1] +\r\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\r\n                                        diffs[pointer - 1][1].length);\r\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\r\n        diffs.splice(pointer - 1, 1);\r\n        changes = true;\r\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\r\n          diffs[pointer + 1][1]) {\r\n        // Shift the edit over the next equality.\r\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\r\n        diffs[pointer][1] =\r\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\r\n            diffs[pointer + 1][1];\r\n        diffs.splice(pointer + 1, 1);\r\n        changes = true;\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n  // If shifts were made, the diff needs reordering and another shift sweep.\r\n  if (changes) {\r\n    this.diff_cleanupMerge(diffs);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * loc is a location in text1, compute and return the equivalent location in\r\n * text2.\r\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @param {number} loc Location within text1.\r\n * @return {number} Location within text2.\r\n */\r\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\r\n  var chars1 = 0;\r\n  var chars2 = 0;\r\n  var last_chars1 = 0;\r\n  var last_chars2 = 0;\r\n  var x;\r\n  for (x = 0; x < diffs.length; x++) {\r\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\r\n      chars1 += diffs[x][1].length;\r\n    }\r\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\r\n      chars2 += diffs[x][1].length;\r\n    }\r\n    if (chars1 > loc) {  // Overshot the location.\r\n      break;\r\n    }\r\n    last_chars1 = chars1;\r\n    last_chars2 = chars2;\r\n  }\r\n  // Was the location was deleted?\r\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\r\n    return last_chars2;\r\n  }\r\n  // Add the remaining character length.\r\n  return last_chars2 + (loc - last_chars1);\r\n};\r\n\r\n\r\n/**\r\n * Convert a diff array into a pretty HTML report.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} HTML representation.\r\n */\r\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\r\n  var html = [];\r\n  var pattern_amp = /&/g;\r\n  var pattern_lt = /</g;\r\n  var pattern_gt = />/g;\r\n  var pattern_para = /\\n/g;\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\r\n    var data = diffs[x][1];  // Text of change.\r\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\r\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\r\n    switch (op) {\r\n      case DIFF_INSERT:\r\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\r\n        break;\r\n      case DIFF_DELETE:\r\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\r\n        break;\r\n      case DIFF_EQUAL:\r\n        html[x] = '<span>' + text + '</span>';\r\n        break;\r\n    }\r\n  }\r\n  return html.join('');\r\n};\r\n\r\n\r\n/**\r\n * Compute and return the source text (all equalities and deletions).\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} Source text.\r\n */\r\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\r\n  var text = [];\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    if (diffs[x][0] !== DIFF_INSERT) {\r\n      text[x] = diffs[x][1];\r\n    }\r\n  }\r\n  return text.join('');\r\n};\r\n\r\n\r\n/**\r\n * Compute and return the destination text (all equalities and insertions).\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} Destination text.\r\n */\r\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\r\n  var text = [];\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    if (diffs[x][0] !== DIFF_DELETE) {\r\n      text[x] = diffs[x][1];\r\n    }\r\n  }\r\n  return text.join('');\r\n};\r\n\r\n\r\n/**\r\n * Compute the Levenshtein distance; the number of inserted, deleted or\r\n * substituted characters.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {number} Number of changes.\r\n */\r\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\r\n  var levenshtein = 0;\r\n  var insertions = 0;\r\n  var deletions = 0;\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var op = diffs[x][0];\r\n    var data = diffs[x][1];\r\n    switch (op) {\r\n      case DIFF_INSERT:\r\n        insertions += data.length;\r\n        break;\r\n      case DIFF_DELETE:\r\n        deletions += data.length;\r\n        break;\r\n      case DIFF_EQUAL:\r\n        // A deletion and an insertion is one substitution.\r\n        levenshtein += Math.max(insertions, deletions);\r\n        insertions = 0;\r\n        deletions = 0;\r\n        break;\r\n    }\r\n  }\r\n  levenshtein += Math.max(insertions, deletions);\r\n  return levenshtein;\r\n};\r\n\r\n\r\n/**\r\n * Crush the diff into an encoded string which describes the operations\r\n * required to transform text1 into text2.\r\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\r\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} Delta text.\r\n */\r\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\r\n  var text = [];\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    switch (diffs[x][0]) {\r\n      case DIFF_INSERT:\r\n        text[x] = '+' + encodeURI(diffs[x][1]);\r\n        break;\r\n      case DIFF_DELETE:\r\n        text[x] = '-' + diffs[x][1].length;\r\n        break;\r\n      case DIFF_EQUAL:\r\n        text[x] = '=' + diffs[x][1].length;\r\n        break;\r\n    }\r\n  }\r\n  return text.join('\\t').replace(/%20/g, ' ');\r\n};\r\n\r\n\r\n/**\r\n * Given the original text1, and an encoded string which describes the\r\n * operations required to transform text1 into text2, compute the full diff.\r\n * @param {string} text1 Source string for the diff.\r\n * @param {string} delta Delta text.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @throws {!Error} If invalid input.\r\n */\r\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\r\n  var diffs = [];\r\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\r\n  var pointer = 0;  // Cursor in text1\r\n  var tokens = delta.split(/\\t/g);\r\n  for (var x = 0; x < tokens.length; x++) {\r\n    // Each token begins with a one character parameter which specifies the\r\n    // operation of this token (delete, insert, equality).\r\n    var param = tokens[x].substring(1);\r\n    switch (tokens[x].charAt(0)) {\r\n      case '+':\r\n        try {\r\n          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\r\n        } catch (ex) {\r\n          // Malformed URI sequence.\r\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\r\n        }\r\n        break;\r\n      case '-':\r\n        // Fall through.\r\n      case '=':\r\n        var n = parseInt(param, 10);\r\n        if (isNaN(n) || n < 0) {\r\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\r\n        }\r\n        var text = text1.substring(pointer, pointer += n);\r\n        if (tokens[x].charAt(0) == '=') {\r\n          diffs[diffsLength++] = [DIFF_EQUAL, text];\r\n        } else {\r\n          diffs[diffsLength++] = [DIFF_DELETE, text];\r\n        }\r\n        break;\r\n      default:\r\n        // Blank tokens are ok (from a trailing \\t).\r\n        // Anything else is an error.\r\n        if (tokens[x]) {\r\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\r\n                          tokens[x]);\r\n        }\r\n    }\r\n  }\r\n  if (pointer != text1.length) {\r\n    throw new Error('Delta length (' + pointer +\r\n        ') does not equal source text length (' + text1.length + ').');\r\n  }\r\n  return diffs;\r\n};\r\n\r\n\r\n//  MATCH FUNCTIONS\r\n\r\n\r\n/**\r\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\r\n * @param {string} text The text to search.\r\n * @param {string} pattern The pattern to search for.\r\n * @param {number} loc The location to search around.\r\n * @return {number} Best match index or -1.\r\n */\r\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\r\n  // Check for null inputs.\r\n  if (text == null || pattern == null || loc == null) {\r\n    throw new Error('Null input. (match_main)');\r\n  }\r\n\r\n  loc = Math.max(0, Math.min(loc, text.length));\r\n  if (text == pattern) {\r\n    // Shortcut (potentially not guaranteed by the algorithm)\r\n    return 0;\r\n  } else if (!text.length) {\r\n    // Nothing to match.\r\n    return -1;\r\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\r\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\r\n    return loc;\r\n  } else {\r\n    // Do a fuzzy compare.\r\n    return this.match_bitap_(text, pattern, loc);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\r\n * Bitap algorithm.\r\n * @param {string} text The text to search.\r\n * @param {string} pattern The pattern to search for.\r\n * @param {number} loc The location to search around.\r\n * @return {number} Best match index or -1.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\r\n  if (pattern.length > this.Match_MaxBits) {\r\n    throw new Error('Pattern too long for this browser.');\r\n  }\r\n\r\n  // Initialise the alphabet.\r\n  var s = this.match_alphabet_(pattern);\r\n\r\n  var dmp = this;  // 'this' becomes 'window' in a closure.\r\n\r\n  /**\r\n   * Compute and return the score for a match with e errors and x location.\r\n   * Accesses loc and pattern through being a closure.\r\n   * @param {number} e Number of errors in match.\r\n   * @param {number} x Location of match.\r\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\r\n   * @private\r\n   */\r\n  function match_bitapScore_(e, x) {\r\n    var accuracy = e / pattern.length;\r\n    var proximity = Math.abs(loc - x);\r\n    if (!dmp.Match_Distance) {\r\n      // Dodge divide by zero error.\r\n      return proximity ? 1.0 : accuracy;\r\n    }\r\n    return accuracy + (proximity / dmp.Match_Distance);\r\n  }\r\n\r\n  // Highest score beyond which we give up.\r\n  var score_threshold = this.Match_Threshold;\r\n  // Is there a nearby exact match? (speedup)\r\n  var best_loc = text.indexOf(pattern, loc);\r\n  if (best_loc != -1) {\r\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\r\n    // What about in the other direction? (speedup)\r\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\r\n    if (best_loc != -1) {\r\n      score_threshold =\r\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\r\n    }\r\n  }\r\n\r\n  // Initialise the bit arrays.\r\n  var matchmask = 1 << (pattern.length - 1);\r\n  best_loc = -1;\r\n\r\n  var bin_min, bin_mid;\r\n  var bin_max = pattern.length + text.length;\r\n  var last_rd;\r\n  for (var d = 0; d < pattern.length; d++) {\r\n    // Scan for the best match; each iteration allows for one more error.\r\n    // Run a binary search to determine how far from 'loc' we can stray at this\r\n    // error level.\r\n    bin_min = 0;\r\n    bin_mid = bin_max;\r\n    while (bin_min < bin_mid) {\r\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\r\n        bin_min = bin_mid;\r\n      } else {\r\n        bin_max = bin_mid;\r\n      }\r\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\r\n    }\r\n    // Use the result from this iteration as the maximum for the next.\r\n    bin_max = bin_mid;\r\n    var start = Math.max(1, loc - bin_mid + 1);\r\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\r\n\r\n    var rd = Array(finish + 2);\r\n    rd[finish + 1] = (1 << d) - 1;\r\n    for (var j = finish; j >= start; j--) {\r\n      // The alphabet (s) is a sparse hash, so the following line generates\r\n      // warnings.\r\n      var charMatch = s[text.charAt(j - 1)];\r\n      if (d === 0) {  // First pass: exact match.\r\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\r\n      } else {  // Subsequent passes: fuzzy match.\r\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\r\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\r\n                last_rd[j + 1];\r\n      }\r\n      if (rd[j] & matchmask) {\r\n        var score = match_bitapScore_(d, j - 1);\r\n        // This match will almost certainly be better than any existing match.\r\n        // But check anyway.\r\n        if (score <= score_threshold) {\r\n          // Told you so.\r\n          score_threshold = score;\r\n          best_loc = j - 1;\r\n          if (best_loc > loc) {\r\n            // When passing loc, don't exceed our current distance from loc.\r\n            start = Math.max(1, 2 * loc - best_loc);\r\n          } else {\r\n            // Already passed loc, downhill from here on in.\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // No hope for a (better) match at greater error levels.\r\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\r\n      break;\r\n    }\r\n    last_rd = rd;\r\n  }\r\n  return best_loc;\r\n};\r\n\r\n\r\n/**\r\n * Initialise the alphabet for the Bitap algorithm.\r\n * @param {string} pattern The text to encode.\r\n * @return {!Object} Hash of character locations.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\r\n  var s = {};\r\n  for (var i = 0; i < pattern.length; i++) {\r\n    s[pattern.charAt(i)] = 0;\r\n  }\r\n  for (var i = 0; i < pattern.length; i++) {\r\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\r\n  }\r\n  return s;\r\n};\r\n\r\n\r\n//  PATCH FUNCTIONS\r\n\r\n\r\n/**\r\n * Increase the context until it is unique,\r\n * but don't let the pattern expand beyond Match_MaxBits.\r\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\r\n * @param {string} text Source text.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\r\n  if (text.length == 0) {\r\n    return;\r\n  }\r\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\r\n  var padding = 0;\r\n\r\n  // Look for the first and last matches of pattern in text.  If two different\r\n  // matches are found, increase the pattern length.\r\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\r\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\r\n         this.Patch_Margin) {\r\n    padding += this.Patch_Margin;\r\n    pattern = text.substring(patch.start2 - padding,\r\n                             patch.start2 + patch.length1 + padding);\r\n  }\r\n  // Add one chunk for good luck.\r\n  padding += this.Patch_Margin;\r\n\r\n  // Add the prefix.\r\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\r\n  if (prefix) {\r\n    patch.diffs.unshift([DIFF_EQUAL, prefix]);\r\n  }\r\n  // Add the suffix.\r\n  var suffix = text.substring(patch.start2 + patch.length1,\r\n                              patch.start2 + patch.length1 + padding);\r\n  if (suffix) {\r\n    patch.diffs.push([DIFF_EQUAL, suffix]);\r\n  }\r\n\r\n  // Roll back the start points.\r\n  patch.start1 -= prefix.length;\r\n  patch.start2 -= prefix.length;\r\n  // Extend the lengths.\r\n  patch.length1 += prefix.length + suffix.length;\r\n  patch.length2 += prefix.length + suffix.length;\r\n};\r\n\r\n\r\n/**\r\n * Compute a list of patches to turn text1 into text2.\r\n * Use diffs if provided, otherwise compute it ourselves.\r\n * There are four ways to call this function, depending on what data is\r\n * available to the caller:\r\n * Method 1:\r\n * a = text1, b = text2\r\n * Method 2:\r\n * a = diffs\r\n * Method 3 (optimal):\r\n * a = text1, b = diffs\r\n * Method 4 (deprecated, use method 3):\r\n * a = text1, b = text2, c = diffs\r\n *\r\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\r\n * Array of diff tuples for text1 to text2 (method 2).\r\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or\r\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\r\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples\r\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\r\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n */\r\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\r\n  var text1, diffs;\r\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\r\n      typeof opt_c == 'undefined') {\r\n    // Method 1: text1, text2\r\n    // Compute diffs from text1 and text2.\r\n    text1 = /** @type {string} */(a);\r\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\r\n    if (diffs.length > 2) {\r\n      this.diff_cleanupSemantic(diffs);\r\n      this.diff_cleanupEfficiency(diffs);\r\n    }\r\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\r\n      typeof opt_c == 'undefined') {\r\n    // Method 2: diffs\r\n    // Compute text1 from diffs.\r\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\r\n    text1 = this.diff_text1(diffs);\r\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\r\n      typeof opt_c == 'undefined') {\r\n    // Method 3: text1, diffs\r\n    text1 = /** @type {string} */(a);\r\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\r\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\r\n      opt_c && typeof opt_c == 'object') {\r\n    // Method 4: text1, text2, diffs\r\n    // text2 is not used.\r\n    text1 = /** @type {string} */(a);\r\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\r\n  } else {\r\n    throw new Error('Unknown call format to patch_make.');\r\n  }\r\n\r\n  if (diffs.length === 0) {\r\n    return [];  // Get rid of the null case.\r\n  }\r\n  var patches = [];\r\n  var patch = new diff_match_patch.patch_obj();\r\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\r\n  var char_count1 = 0;  // Number of characters into the text1 string.\r\n  var char_count2 = 0;  // Number of characters into the text2 string.\r\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\r\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\r\n  // context info.\r\n  var prepatch_text = text1;\r\n  var postpatch_text = text1;\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var diff_type = diffs[x][0];\r\n    var diff_text = diffs[x][1];\r\n\r\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\r\n      // A new patch starts here.\r\n      patch.start1 = char_count1;\r\n      patch.start2 = char_count2;\r\n    }\r\n\r\n    switch (diff_type) {\r\n      case DIFF_INSERT:\r\n        patch.diffs[patchDiffLength++] = diffs[x];\r\n        patch.length2 += diff_text.length;\r\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\r\n                         postpatch_text.substring(char_count2);\r\n        break;\r\n      case DIFF_DELETE:\r\n        patch.length1 += diff_text.length;\r\n        patch.diffs[patchDiffLength++] = diffs[x];\r\n        postpatch_text = postpatch_text.substring(0, char_count2) +\r\n                         postpatch_text.substring(char_count2 +\r\n                             diff_text.length);\r\n        break;\r\n      case DIFF_EQUAL:\r\n        if (diff_text.length <= 2 * this.Patch_Margin &&\r\n            patchDiffLength && diffs.length != x + 1) {\r\n          // Small equality inside a patch.\r\n          patch.diffs[patchDiffLength++] = diffs[x];\r\n          patch.length1 += diff_text.length;\r\n          patch.length2 += diff_text.length;\r\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\r\n          // Time for a new patch.\r\n          if (patchDiffLength) {\r\n            this.patch_addContext_(patch, prepatch_text);\r\n            patches.push(patch);\r\n            patch = new diff_match_patch.patch_obj();\r\n            patchDiffLength = 0;\r\n            // Unlike Unidiff, our patch lists have a rolling context.\r\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\r\n            // Update prepatch text & pos to reflect the application of the\r\n            // just completed patch.\r\n            prepatch_text = postpatch_text;\r\n            char_count1 = char_count2;\r\n          }\r\n        }\r\n        break;\r\n    }\r\n\r\n    // Update the current character count.\r\n    if (diff_type !== DIFF_INSERT) {\r\n      char_count1 += diff_text.length;\r\n    }\r\n    if (diff_type !== DIFF_DELETE) {\r\n      char_count2 += diff_text.length;\r\n    }\r\n  }\r\n  // Pick up the leftover patch if not empty.\r\n  if (patchDiffLength) {\r\n    this.patch_addContext_(patch, prepatch_text);\r\n    patches.push(patch);\r\n  }\r\n\r\n  return patches;\r\n};\r\n\r\n\r\n/**\r\n * Given an array of patches, return another array that is identical.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n */\r\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\r\n  // Making deep copies is hard in JavaScript.\r\n  var patchesCopy = [];\r\n  for (var x = 0; x < patches.length; x++) {\r\n    var patch = patches[x];\r\n    var patchCopy = new diff_match_patch.patch_obj();\r\n    patchCopy.diffs = [];\r\n    for (var y = 0; y < patch.diffs.length; y++) {\r\n      patchCopy.diffs[y] = patch.diffs[y].slice();\r\n    }\r\n    patchCopy.start1 = patch.start1;\r\n    patchCopy.start2 = patch.start2;\r\n    patchCopy.length1 = patch.length1;\r\n    patchCopy.length2 = patch.length2;\r\n    patchesCopy[x] = patchCopy;\r\n  }\r\n  return patchesCopy;\r\n};\r\n\r\n\r\n/**\r\n * Merge a set of patches onto the text.  Return a patched text, as well\r\n * as a list of true/false values indicating which patches were applied.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @param {string} text Old text.\r\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\r\n *      new text and an array of boolean values.\r\n */\r\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\r\n  if (patches.length == 0) {\r\n    return [text, []];\r\n  }\r\n\r\n  // Deep copy the patches so that no changes are made to originals.\r\n  patches = this.patch_deepCopy(patches);\r\n\r\n  var nullPadding = this.patch_addPadding(patches);\r\n  text = nullPadding + text + nullPadding;\r\n\r\n  this.patch_splitMax(patches);\r\n  // delta keeps track of the offset between the expected and actual location\r\n  // of the previous patch.  If there are patches expected at positions 10 and\r\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\r\n  // has an effective expected position of 22.\r\n  var delta = 0;\r\n  var results = [];\r\n  for (var x = 0; x < patches.length; x++) {\r\n    var expected_loc = patches[x].start2 + delta;\r\n    var text1 = this.diff_text1(patches[x].diffs);\r\n    var start_loc;\r\n    var end_loc = -1;\r\n    if (text1.length > this.Match_MaxBits) {\r\n      // patch_splitMax will only provide an oversized pattern in the case of\r\n      // a monster delete.\r\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\r\n                                  expected_loc);\r\n      if (start_loc != -1) {\r\n        end_loc = this.match_main(text,\r\n            text1.substring(text1.length - this.Match_MaxBits),\r\n            expected_loc + text1.length - this.Match_MaxBits);\r\n        if (end_loc == -1 || start_loc >= end_loc) {\r\n          // Can't find valid trailing context.  Drop this patch.\r\n          start_loc = -1;\r\n        }\r\n      }\r\n    } else {\r\n      start_loc = this.match_main(text, text1, expected_loc);\r\n    }\r\n    if (start_loc == -1) {\r\n      // No match found.  :(\r\n      results[x] = false;\r\n      // Subtract the delta for this failed patch from subsequent patches.\r\n      delta -= patches[x].length2 - patches[x].length1;\r\n    } else {\r\n      // Found a match.  :)\r\n      results[x] = true;\r\n      delta = start_loc - expected_loc;\r\n      var text2;\r\n      if (end_loc == -1) {\r\n        text2 = text.substring(start_loc, start_loc + text1.length);\r\n      } else {\r\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\r\n      }\r\n      if (text1 == text2) {\r\n        // Perfect match, just shove the replacement text in.\r\n        text = text.substring(0, start_loc) +\r\n               this.diff_text2(patches[x].diffs) +\r\n               text.substring(start_loc + text1.length);\r\n      } else {\r\n        // Imperfect match.  Run a diff to get a framework of equivalent\r\n        // indices.\r\n        var diffs = this.diff_main(text1, text2, false);\r\n        if (text1.length > this.Match_MaxBits &&\r\n            this.diff_levenshtein(diffs) / text1.length >\r\n            this.Patch_DeleteThreshold) {\r\n          // The end points match, but the content is unacceptably bad.\r\n          results[x] = false;\r\n        } else {\r\n          this.diff_cleanupSemanticLossless(diffs);\r\n          var index1 = 0;\r\n          var index2;\r\n          for (var y = 0; y < patches[x].diffs.length; y++) {\r\n            var mod = patches[x].diffs[y];\r\n            if (mod[0] !== DIFF_EQUAL) {\r\n              index2 = this.diff_xIndex(diffs, index1);\r\n            }\r\n            if (mod[0] === DIFF_INSERT) {  // Insertion\r\n              text = text.substring(0, start_loc + index2) + mod[1] +\r\n                     text.substring(start_loc + index2);\r\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\r\n              text = text.substring(0, start_loc + index2) +\r\n                     text.substring(start_loc + this.diff_xIndex(diffs,\r\n                         index1 + mod[1].length));\r\n            }\r\n            if (mod[0] !== DIFF_DELETE) {\r\n              index1 += mod[1].length;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Strip the padding off.\r\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\r\n  return [text, results];\r\n};\r\n\r\n\r\n/**\r\n * Add some padding on text start and end so that edges can match something.\r\n * Intended to be called only from within patch_apply.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @return {string} The padding string added to each side.\r\n */\r\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\r\n  var paddingLength = this.Patch_Margin;\r\n  var nullPadding = '';\r\n  for (var x = 1; x <= paddingLength; x++) {\r\n    nullPadding += String.fromCharCode(x);\r\n  }\r\n\r\n  // Bump all the patches forward.\r\n  for (var x = 0; x < patches.length; x++) {\r\n    patches[x].start1 += paddingLength;\r\n    patches[x].start2 += paddingLength;\r\n  }\r\n\r\n  // Add some padding on start of first diff.\r\n  var patch = patches[0];\r\n  var diffs = patch.diffs;\r\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\r\n    // Add nullPadding equality.\r\n    diffs.unshift([DIFF_EQUAL, nullPadding]);\r\n    patch.start1 -= paddingLength;  // Should be 0.\r\n    patch.start2 -= paddingLength;  // Should be 0.\r\n    patch.length1 += paddingLength;\r\n    patch.length2 += paddingLength;\r\n  } else if (paddingLength > diffs[0][1].length) {\r\n    // Grow first equality.\r\n    var extraLength = paddingLength - diffs[0][1].length;\r\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\r\n    patch.start1 -= extraLength;\r\n    patch.start2 -= extraLength;\r\n    patch.length1 += extraLength;\r\n    patch.length2 += extraLength;\r\n  }\r\n\r\n  // Add some padding on end of last diff.\r\n  patch = patches[patches.length - 1];\r\n  diffs = patch.diffs;\r\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\r\n    // Add nullPadding equality.\r\n    diffs.push([DIFF_EQUAL, nullPadding]);\r\n    patch.length1 += paddingLength;\r\n    patch.length2 += paddingLength;\r\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\r\n    // Grow last equality.\r\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\r\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\r\n    patch.length1 += extraLength;\r\n    patch.length2 += extraLength;\r\n  }\r\n\r\n  return nullPadding;\r\n};\r\n\r\n\r\n/**\r\n * Look through the patches and break up any which are longer than the maximum\r\n * limit of the match algorithm.\r\n * Intended to be called only from within patch_apply.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n */\r\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\r\n  var patch_size = this.Match_MaxBits;\r\n  for (var x = 0; x < patches.length; x++) {\r\n    if (patches[x].length1 <= patch_size) {\r\n      continue;\r\n    }\r\n    var bigpatch = patches[x];\r\n    // Remove the big old patch.\r\n    patches.splice(x--, 1);\r\n    var start1 = bigpatch.start1;\r\n    var start2 = bigpatch.start2;\r\n    var precontext = '';\r\n    while (bigpatch.diffs.length !== 0) {\r\n      // Create one of several smaller patches.\r\n      var patch = new diff_match_patch.patch_obj();\r\n      var empty = true;\r\n      patch.start1 = start1 - precontext.length;\r\n      patch.start2 = start2 - precontext.length;\r\n      if (precontext !== '') {\r\n        patch.length1 = patch.length2 = precontext.length;\r\n        patch.diffs.push([DIFF_EQUAL, precontext]);\r\n      }\r\n      while (bigpatch.diffs.length !== 0 &&\r\n             patch.length1 < patch_size - this.Patch_Margin) {\r\n        var diff_type = bigpatch.diffs[0][0];\r\n        var diff_text = bigpatch.diffs[0][1];\r\n        if (diff_type === DIFF_INSERT) {\r\n          // Insertions are harmless.\r\n          patch.length2 += diff_text.length;\r\n          start2 += diff_text.length;\r\n          patch.diffs.push(bigpatch.diffs.shift());\r\n          empty = false;\r\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\r\n                   patch.diffs[0][0] == DIFF_EQUAL &&\r\n                   diff_text.length > 2 * patch_size) {\r\n          // This is a large deletion.  Let it pass in one chunk.\r\n          patch.length1 += diff_text.length;\r\n          start1 += diff_text.length;\r\n          empty = false;\r\n          patch.diffs.push([diff_type, diff_text]);\r\n          bigpatch.diffs.shift();\r\n        } else {\r\n          // Deletion or equality.  Only take as much as we can stomach.\r\n          diff_text = diff_text.substring(0,\r\n              patch_size - patch.length1 - this.Patch_Margin);\r\n          patch.length1 += diff_text.length;\r\n          start1 += diff_text.length;\r\n          if (diff_type === DIFF_EQUAL) {\r\n            patch.length2 += diff_text.length;\r\n            start2 += diff_text.length;\r\n          } else {\r\n            empty = false;\r\n          }\r\n          patch.diffs.push([diff_type, diff_text]);\r\n          if (diff_text == bigpatch.diffs[0][1]) {\r\n            bigpatch.diffs.shift();\r\n          } else {\r\n            bigpatch.diffs[0][1] =\r\n                bigpatch.diffs[0][1].substring(diff_text.length);\r\n          }\r\n        }\r\n      }\r\n      // Compute the head context for the next patch.\r\n      precontext = this.diff_text2(patch.diffs);\r\n      precontext =\r\n          precontext.substring(precontext.length - this.Patch_Margin);\r\n      // Append the end context for this patch.\r\n      var postcontext = this.diff_text1(bigpatch.diffs)\r\n                            .substring(0, this.Patch_Margin);\r\n      if (postcontext !== '') {\r\n        patch.length1 += postcontext.length;\r\n        patch.length2 += postcontext.length;\r\n        if (patch.diffs.length !== 0 &&\r\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\r\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\r\n        } else {\r\n          patch.diffs.push([DIFF_EQUAL, postcontext]);\r\n        }\r\n      }\r\n      if (!empty) {\r\n        patches.splice(++x, 0, patch);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Take a list of patches and return a textual representation.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @return {string} Text representation of patches.\r\n */\r\ndiff_match_patch.prototype.patch_toText = function(patches) {\r\n  var text = [];\r\n  for (var x = 0; x < patches.length; x++) {\r\n    text[x] = patches[x];\r\n  }\r\n  return text.join('');\r\n};\r\n\r\n\r\n/**\r\n * Parse a textual representation of patches and return a list of Patch objects.\r\n * @param {string} textline Text representation of patches.\r\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n * @throws {!Error} If invalid input.\r\n */\r\ndiff_match_patch.prototype.patch_fromText = function(textline) {\r\n  var patches = [];\r\n  if (!textline) {\r\n    return patches;\r\n  }\r\n  var text = textline.split('\\n');\r\n  var textPointer = 0;\r\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\r\n  while (textPointer < text.length) {\r\n    var m = text[textPointer].match(patchHeader);\r\n    if (!m) {\r\n      throw new Error('Invalid patch string: ' + text[textPointer]);\r\n    }\r\n    var patch = new diff_match_patch.patch_obj();\r\n    patches.push(patch);\r\n    patch.start1 = parseInt(m[1], 10);\r\n    if (m[2] === '') {\r\n      patch.start1--;\r\n      patch.length1 = 1;\r\n    } else if (m[2] == '0') {\r\n      patch.length1 = 0;\r\n    } else {\r\n      patch.start1--;\r\n      patch.length1 = parseInt(m[2], 10);\r\n    }\r\n\r\n    patch.start2 = parseInt(m[3], 10);\r\n    if (m[4] === '') {\r\n      patch.start2--;\r\n      patch.length2 = 1;\r\n    } else if (m[4] == '0') {\r\n      patch.length2 = 0;\r\n    } else {\r\n      patch.start2--;\r\n      patch.length2 = parseInt(m[4], 10);\r\n    }\r\n    textPointer++;\r\n\r\n    while (textPointer < text.length) {\r\n      var sign = text[textPointer].charAt(0);\r\n      try {\r\n        var line = decodeURI(text[textPointer].substring(1));\r\n      } catch (ex) {\r\n        // Malformed URI sequence.\r\n        throw new Error('Illegal escape in patch_fromText: ' + line);\r\n      }\r\n      if (sign == '-') {\r\n        // Deletion.\r\n        patch.diffs.push([DIFF_DELETE, line]);\r\n      } else if (sign == '+') {\r\n        // Insertion.\r\n        patch.diffs.push([DIFF_INSERT, line]);\r\n      } else if (sign == ' ') {\r\n        // Minor equality.\r\n        patch.diffs.push([DIFF_EQUAL, line]);\r\n      } else if (sign == '@') {\r\n        // Start of next patch.\r\n        break;\r\n      } else if (sign === '') {\r\n        // Blank line?  Whatever.\r\n      } else {\r\n        // WTF?\r\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\r\n      }\r\n      textPointer++;\r\n    }\r\n  }\r\n  return patches;\r\n};\r\n\r\n\r\n/**\r\n * Class representing one patch operation.\r\n * @constructor\r\n */\r\ndiff_match_patch.patch_obj = function() {\r\n  /** @type {!Array.<!diff_match_patch.Diff>} */\r\n  this.diffs = [];\r\n  /** @type {?number} */\r\n  this.start1 = null;\r\n  /** @type {?number} */\r\n  this.start2 = null;\r\n  /** @type {number} */\r\n  this.length1 = 0;\r\n  /** @type {number} */\r\n  this.length2 = 0;\r\n};\r\n\r\n\r\n/**\r\n * Emmulate GNU diff's format.\r\n * Header: @@ -382,8 +481,9 @@\r\n * Indicies are printed as 1-based, not 0-based.\r\n * @return {string} The GNU diff string.\r\n */\r\ndiff_match_patch.patch_obj.prototype.toString = function() {\r\n  var coords1, coords2;\r\n  if (this.length1 === 0) {\r\n    coords1 = this.start1 + ',0';\r\n  } else if (this.length1 == 1) {\r\n    coords1 = this.start1 + 1;\r\n  } else {\r\n    coords1 = (this.start1 + 1) + ',' + this.length1;\r\n  }\r\n  if (this.length2 === 0) {\r\n    coords2 = this.start2 + ',0';\r\n  } else if (this.length2 == 1) {\r\n    coords2 = this.start2 + 1;\r\n  } else {\r\n    coords2 = (this.start2 + 1) + ',' + this.length2;\r\n  }\r\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\r\n  var op;\r\n  // Escape the body of the patch with %xx notation.\r\n  for (var x = 0; x < this.diffs.length; x++) {\r\n    switch (this.diffs[x][0]) {\r\n      case DIFF_INSERT:\r\n        op = '+';\r\n        break;\r\n      case DIFF_DELETE:\r\n        op = '-';\r\n        break;\r\n      case DIFF_EQUAL:\r\n        op = ' ';\r\n        break;\r\n    }\r\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\r\n  }\r\n  return text.join('').replace(/%20/g, ' ');\r\n};\r\n\r\n\r\n// The following export code was added by @ForbesLindesay\r\nmodule.exports = diff_match_patch;\r\nmodule.exports['diff_match_patch'] = diff_match_patch;\r\nmodule.exports['DIFF_DELETE'] = DIFF_DELETE;\r\nmodule.exports['DIFF_INSERT'] = DIFF_INSERT;\r\nmodule.exports['DIFF_EQUAL'] = DIFF_EQUAL;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/diff-match-patch/index.js\n// module id = 84\n// module chunks = 0","let enableArrayEquals = () => {\n  // Warn if overriding existing method\n  if(Array.prototype.equals) console.warn('Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there\\'s a framework conflict or you\\'ve got double inclusions in your code.')\n  // attach the .equals method to Array's prototype to call it on any array\n  Array.prototype.equals = function (array) {\n    // if the other array is a falsy value, return\n    if (!array) return false\n\n    // compare lengths - can save a lot of time\n    if (this.length != array.length) return false\n\n    for (var i = 0, l=this.length; i < l; i++) {\n      // Check if we have nested arrays\n      if (this[i] instanceof Array && array[i] instanceof Array) {\n        // recurse into the nested arrays\n        if (!this[i].equals(array[i])) return false\n      }\n      else if (this[i] != array[i]) {\n        // Warning - two different object instances will never be equal: {x:20} != {x:20}\n        return false\n      }\n    }\n    return true\n  }\n  // Hide method from for-in loops\n  Object.defineProperty(Array.prototype, 'equals', {enumerable: false})\n}\n\nexport default {\n  enableArrayEquals: enableArrayEquals\n}\n\n\n// WEBPACK FOOTER //\n// ./src/util/index.js"],"sourceRoot":""}